<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Prefix Specification</title>
  <link rel="icon" href="./icon.png" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap');
    body{background:#222;color:#99ddff;font-family:Open Sans, sans-serif;margin:0;padding:1rem}
    .container{max-width:1000px;margin:0 auto;text-align:justify;text-justify:inter-word}
    .container h1{ text-align:center; margin-top:0; }
    pre, code{background:#3c3c3c;color:inherit;font-family:Source Code Pro, monospace;padding:.25rem .5rem}
    img{max-width:100%}
  </style>
</head>
<body>
  <div class="container" id="content">Rendering specification…</div>

  <!-- Markdown source is embedded below. marked.js will render it into #content. -->
  <script id="md" type="text/markdown">
# Prefix Specification

<p align="center">
  <img alt="Prefix icon" src="./icon.png">
</p>

## Table of contents

- [1. Overview](#1-overview)

- [2. Lexical Structure](#2-lexical-structure)

- [3. Data Model](#3-data-model)

- [4. Statements and Control Flow](#4-statements-and-control-flow)

- [5. Functions](#5-functions)

- [6. Variables and Memory Model](#6-variables-and-memory-model)

- [7. Execution Model and Semantics](#7-execution-model-and-semantics)

- [8. Standard Library](#8-standard-library)

- [9. Tracebacks and Error Reporting](#9-tracebacks-and-error-reporting)

- [10. Interpreter Use](#10-interpreter-use)

- [11. REPL (Interactive Mode)](#11-repl-interactive-mode)

- [12. Operators, Functions, and Statements](#12-operators-functions-and-statements)

This document specifies an imperative programming language with a statically typed data model and an explicit small-step execution semantics.

A program is compiled into an initial machine state (a seed configuration) and then executed solely by repeatedly applying a fixed, program-independent state-transition (rewrite) function. All intermediate states are (semi-)human-readable and serializable, and execution can be traced and replayed exactly, including I/O and nondeterministic choices, which are modeled explicitly for deterministic replay.

## 1. Overview

The language is a familiar statement-based, imperative language.

Programs consist of variable declarations via assignment, expressions, and control-flow constructs such as `IF`, `ELSEIF`, `ELSE`, `WHILE`, and `FOR`.

Prefix has seven runtime data types: binary integers (`INT`), binary floating-point numbers (`FLT`, IEEE754), strings (`STR`), non-scalar tensors (`TNS`), first-class user-defined functions (`FUNC`), associative maps (`MAP`), and thread handles (`THR`).

Identifiers, function parameters, and return values are statically typed; the type of every symbol must be declared when it is first introduced. Computation proceeds by evaluating expressions and executing statements in sequence, with explicit constructs for branching and looping. Input and output are modeled through built-in operators, in particular `INPUT` and `PRINT`.

The interpreter compiles source code into a single initial configuration (the seed state), which includes the program code, an empty variable environment, and an initial I/O history. It then advances execution by repeatedly applying a single, fixed small-step transition function that is independent of the particular program. A disassembler and log view expose all intermediate states so that every step and every control-flow decision is inspectable and replay-able.

## 2. Lexical Structure

Source files are sequences of ASCII characters. Non-ASCII characters are not permitted in syntactic elements that enter the program namespace, such as identifiers.

Whitespace consists of the space character (`U+0020`), horizontal tab, carriage return, and line feed. It may appear freely between tokens and is otherwise ignored, except that newlines delimit top-level statements (see Section 5.1).

A comment begins with the `!` character and continues to the end of the current line. Comments have no effect on execution.

Line separator alias: The semicolon character (`;`) is treated by the lexer as a newline-token alias. Whenever a `;` appears in source code outside of a string literal, the lexer emits a `NEWLINE` token (equivalent to a physical newline), so `;` can be used to separate statements on a single physical line.

The program text is divided into several token kinds: binary integer literals (Section 3.1); string literals delimited by double or single quotation marks (`"`, `'`, Section 3.2); identifiers for variable names and user-defined function names (Section 2.5); keywords and built-ins (control-flow keywords, built-in operators and functions; see Sections 5 and 13); and delimiters, namely `(`, `)`, `{`, `}`, `[`, `]`, `,`, `:`, and `=`.

Keywords: The language's reserved keywords (for example, `IF`, `WHILE`, `FUNC`, etc.) are matched by the lexer exactly as listed in this specification and are case-sensitive. Programs must use the keywords in their canonical uppercase form; otherwise the token will be recognized as an identifier. Built-in operator names such as `INPUT`, `PRINT`, and `IMPORT` follow the same case-sensitive matching rules.

Line continuation: The character `^` serves as a line-continuation marker. When a caret `^` appears in the source and is followed immediately by a newline, both the `^` and the newline are ignored by the lexer (that is, the logical line continues on the next physical line). The lexer also accepts a caret immediately before a code note (a comment beginning with `!`); in this case the `^`, the comment text up to the line terminator, and the terminating newline are treated as if they were not present. If a `^` is present in a string, it does not count as a line continuation. If a caret appears and is not immediately followed by a newline, a code note, or the platform's single-character newline sequence, the lexer must raise a syntax error.

The character `-` primarily serves as the leading sign of a numeric literal (Section 3.1). When `-` appears immediately before optional whitespace and then binary digits, it is parsed as part of the numeric literal (that is, a signed literal). In other contexts (for example inside an index expression) a single `-` token is recognized as a dash used for slice notation `lo-hi`. If `-` appears in any other unsupported context the lexer must raise a syntax error.

Identifiers denote variables and user-defined functions. They must be non-empty and case-sensitive. An identifier must not contain non-ASCII characters, nor any of the following characters: `{`, `}`, `[`, `]`, `(`, `)`, `=`, `,`, `!`. The first character of an identifier must not be the digit `0` or `1` (these digits are used to begin binary integer literals). However, the characters `0` and `1` are permitted in subsequent positions within an identifier (for example, `a01` and `X10Y` are valid identifiers, while `0foo` and `1bar` are not). The namespace is flat: variables and functions share a single identifier space, so a given name cannot simultaneously denote both. A user-defined function name must not conflict with the name of any built-in operator or function (see Section 13).

Identifier character set (clarification): The (non-empty) sequence of characters that forms an identifier is determined by the following rules, which match the reference lexer implementation:

- The first character MUST NOT be `0` or `1`. Any other non-ASCII character is disallowed, but otherwise the lexer permits a broad set of ASCII punctuation and symbol characters in addition to letters and digits. In particular, the following characters are valid as the first character of an identifier:

  - Lowercase letters `a`-`z`

  - Uppercase letters `A`-`Z`

  - Decimal digits `2`-`9`

  - The punctuation and symbol characters
    `/ $ % & ~ _ + | ?`

- Subsequent characters in an identifier may be any of the following:

  - Lowercase letters `a`-`z`

  - Uppercase letters `A`-`Z`

  - Decimal digits `0`-`9`

  - The punctuation and symbol characters
    `/ $ % & ~ _ + | ?`

  As noted above, non-ASCII characters remain disallowed, and the delimiter characters `{`, `}`, `(`, `)`, `=`, `,`, and `!` are never permitted inside identifiers.

This deliberately-permissive identifier character set preserves an unambiguous lexical distinction between binary integer literals (which must begin with `0` or `1`) and identifiers, while allowing module-qualified names and other symbolic conventions to be expressed directly as plain identifiers in source code.

### Pointer operator

The `@` character is a dedicated lexical token (not part of an identifier). When written before an identifier it produces a pointer literal that denotes an alias to an existing identifier in the current lexical environment. The pointer literal syntax is `@name` and is parsed as a distinct expression (see Section 6 for runtime semantics). Because `@` is a separate token it may not appear inside an identifier name.


## 3. Data Model

Prefix supports seven runtime data types: binary integers, binary floating-point numbers, strings, non-scalar tensors, first-class functions, associative maps, and thread handles.

Binary integer literal: an unsigned non-empty sequence of `{0,1}` (for example, `0`, `1`, `1011`), or a signed literal formed by a leading `-` (the dash is part of the literal, not an operator) followed by optional spaces, tabs, or carriage returns and then a non-empty sequence of `{0,1}`. A `-` that does not immediately introduce a literal is a syntax error.

Binary floating-point literal: an IEEE754 floating-point value written in binary fixed-point notation `n.n`, where both sides of the radix point are non-empty sequences of `{0,1}`. Examples:

- `0.1` denotes one-half.

- `0.01` denotes one-quarter.

- `0.11` denotes three-quarters.

`FLT` literals must not begin with the radix point (so `.1` is invalid). A leading `-` may prefix a `FLT` literal using the same rules as for integers (the dash is part of the literal and is not an operator).

String literal: a sequence of characters enclosed in either double quotation marks (`"`) or single quotation marks (`'`). A string opened with one delimiter must be closed with the same delimiter. Newlines are not permitted inside string literals.

String literals support backslash escape codes. Unknown escape codes (or invalid hexadecimal literals in `\x`/`\u`/`\U`) raise syntax errors at parse time.

Supported escape codes:

- `\\` = U+005C

- `\"` = U+0022

- `\'` = U+0027

- `\a` = U+0007

- `\b` = U+0008

- `\f` = U+000C

- `\n` = U+000A

- `\r` = U+000D

- `\t` = U+0009

- `\v` = U+000B

- `\e` = U+001B

- `\xHH` = exactly two hex digits (0-9A-Fa-f). Produces code point U+00..U+FF specified by 0xHH.

- `\uHHHH` = exactly four hex digits. Produces code point U+HHHH.

- `\UHHHHHHHH` = exactly eight hex digits. Produces code point U+HHHHHHHH.

Raw-mode escape: `\R` toggles raw-mode for the string (until the next `\R` or the end of the string). While raw mode is on, all escape codes (except `\R`) are treated as plaintext (so `\n` contributes the two characters `\` and `n`, and `\"` contributes the two characters `\` and `"`).

Tensor literal: a non-empty bracketed collection of expressions. Each pair of matching brackets introduces a dimension; nested brackets must form a rectangular shape (all sublists at a given depth have the same length) or a syntax error is raised. The outermost bracket corresponds to dimension 1. Examples (lengths shown in binary):

- `[0,1,10]` has shape `[11]` (one dimension of length three).

- `[[0,1,10],[0,10,100]]` has shape `[10,11]`.

- `[[[0,1,10],[1,10,100]]]` has shape `[1,10,11]`.

Expressions inside a tensor literal may themselves evaluate to `INT`, `FLT`, `STR`, or `TNS`. If an element expression evaluates to a tensor value, it occupies a single position and does not contribute additional dimensions; only the explicit bracket structure determines the shape. A tensor literal that mixes sub-brackets of differing lengths is invalid (for example, `[[0,0,0],[1,1]]`).


Map literal and `MAP` type: In addition to tensors, Prefix provides an N-dimensional associative map type `MAP` whose literal form uses angle brackets and key/value pairs. A map literal is written as `<key1 = value1, key2 = value2, ...>`. Values may themselves be maps, allowing nested associative structures. Examples:

- `<"foo" = 1, "bar" = 10>` is a 1-level map with string keys.
- `<"outer" = <"inner" = 1>, "other" = 0>` nests a map value under key `"outer"`.

Map indexing uses angle brackets and a comma-separated key list: `m<k1>` or `m<k1,k2>` to lookup nested values. Keys must be scalar values of type `INT`, `FLT`, or `STR` (tensor values are not permitted as keys). The number of keys supplied may vary between lookups and different keys need not share the same depth: maps are sparse and do not require rectangular shapes.

Maps preserve insertion order: keys are stored in the order they are inserted (left-to-right for keys written in a literal and in the order of creation for keys added later). Iteration and serialized representations of a map reflect this insertion order.

Assignment to a map element uses the same indexed-assignment form as tensors: `map<k1,k2> = expr` binds or updates the nested key. Intermediate nested maps are created on-demand when assigning deeper keys. Each map entry stores its value with a single static type: assigning a different type to an existing key is a runtime error. Keys may be added or removed after the map is created. To delete a key, use the built-in deletion operator: `DEL(map<k>)` removes the mapping for `k`. Examples (REPL):

```
>>> MAP: map = <"foo" = 1, "bar" = 10, "boz" = <"foo" = 11, "bar" = 100>>
>>> PRINT(map<"foo">)
1
>>> PRINT(map<"boz", "foo">)
11
```

Slice indexing: any index position inside `[...]` may be a range of the form `lo-hi` where `lo` and `hi` are ordinary index expressions. A range selects the contiguous inclusive span of positions from `lo` to `hi` (both endpoints follow the same one-based and negative-index rules described above). Slices may be mixed with hard indices (for example, `tensor[lo-hi, i]`) and reduce the dimensionality of the selected result according to which positions are fixed versus sliced: selecting one or more ranges produces a `TNS` value whose shape equals the lengths of the specified ranges (in the same order). Assigning to a slice is supported: the left-hand side may use ranges in its indices, and the right-hand-side expression must evaluate to a `TNS` whose shape exactly matches the selected slice. Elementwise type compatibility is required: each element being written must match the static element type of the target position, otherwise a runtime error is raised. Example: `tensor[10-11] = [1,11]` writes a two-element tensor into the slice consisting of positions `10` and `11`.

Additionally, the symbol `*` may be used in an index position to denote a full-dimension slice selecting every element along that axis (for example, `tensor[*,1]` selects all elements of the first dimension at index `1` of the second dimension).

All other tensor operations are non-mutating: tensor literals and tensor-valued built-ins produce new tensor values rather than mutating existing ones. Because indexed assignment mutates a tensor object, if the same tensor value is aliased (bound to multiple identifiers, passed as an argument, or stored inside another tensor), all aliases observe the mutation.

MAP and `TNS` values are reference (aliasing) types: assigning a `MAP` or `TNS` to another identifier copies a reference to the same underlying container rather than performing an implicit deep copy. Mutating a map (via `map<...> = ...`, `DEL`, or other mutating operators) or mutating a tensor element through indexed assignment will be observed through any other identifier that references the same container. Use the built-in `COPY` (shallow copy) or `DEEPCOPY` (recursive deep copy) operators when a non-aliased duplicate is required.

Every runtime value has a static type: `INT`, `FLT`, `STR`, `TNS`, or `FUNC`. Integers are conceptually unbounded mathematical integers. Floats are IEEE754 binary floating-point numbers. Strings are sequences of characters (source text is ASCII, but escape codes may denote non-ASCII code points). Tensors are non-scalar aggregates whose elements may be `INT`, `FLT`, `STR`, `FUNC`, or `TNS`.

Function value (`FUNC`): a reference to a user-defined function body (including its lexical closure). A `FUNC` value can be stored in variables or tensors, passed as an argument, or returned from a function. The call syntax applies to any expression that evaluates to `FUNC`; for example, `alias()` calls the function bound to `alias`, and `tns[1]()` calls the function stored in that tensor element. `FUNC` values are always truthy; equality compares object identity (two references are equal only if they refer to the same function definition). String rendering produces an implementation-defined placeholder such as `<func name>`.

When a Boolean interpretation is required, `INT` treats 0 as false and non-zero as true; `FLT` treats 0.0 as false and any non-zero value as true; `STR` treats the empty string as false and any non-empty string as true; `TNS` is true if any contained element is true by these rules, otherwise false. Control-flow conditions (`IF`, `ELSEIF`, `WHILE`) and `ASSERT` convert strings to integers using the same rules as the `INT` built-in; tensors are first reduced to their Boolean truth value (1 or 0).

`INT` and `FLT` are not interoperable: no implicit conversion occurs. Operators that accept both types require that all numeric arguments have the same numeric type.

## 4. Statements and Control Flow

A program consists of zero or more statements separated by newlines. Each top-level expression or assignment must appear on its own line. The basic statement forms are assignments of the form `identifier = expression`, expression statements such as calls to `PRINT` whose result is ignored, control-flow constructs (`IF`, `ELSEIF`, `ELSE`, `WHILE`, and `FOR`), and function definitions (`FUNC` declarations; see Section 6).

Blocks group one or more statements and are enclosed in curly brackets: `{ statement1 ... statementN }`. Curly braces must match (that is, `{` closes with `}`). Blocks serve as the bodies of control-flow constructs and functions.

ASYNC blocks: The `ASYNC` statement introduces a background task whose body is a regular block: `ASYNC{ ... }`. The statements inside the block execute synchronously with respect to each other but asynchronously relative to the rest of the program. The block shares the main program namespace (it executes with the same lexical environment), so assignments and mutations performed inside an `ASYNC` block are visible to the rest of the program immediately. Runtime errors raised inside an `ASYNC` block are reported via the interpreter's error hooks and recorded in the state log; they do not synchronously abort the main thread. When `ASYNC{ ... }` appears as a top-level statement the interpreter begins executing the block immediately in a background task and continues with the next statement. When `ASYNC{ ... }` is evaluated in expression position and is used as an argument to a surrounding call expression, the interpreter returns a `THR` handle but defers starting the worker thread until the immediately-enclosing call expression completes; this allows operators that receive the `THR` (for example `PAUSE` or `STOP`) to act on the thread before it begins execution. Note that language invariants still apply inside the `ASYNC` block (for example, `RETURN` outside a function is a runtime error).

Thread values (`THR`): a `THR` value is a handle to a background task. In Boolean contexts, a finished `THR` (including one that has been stopped) is `0`, otherwise it is `1`.

`THR(symbol){ block }`: the `THR` statement starts executing `block` in a background task and binds the identifier `symbol` (static type `THR`) in the current environment to the newly-created thread handle. The spawned task shares the main program namespace (it executes with the same lexical environment) similarly to `ASYNC`.

`ASYNC{ block }` as an expression: `ASYNC{ ... }` may also appear in expression position, where it evaluates to a `THR` handle. In statement position, `ASYNC{ ... }` remains valid and its resulting `THR` value is ignored.

Assignments have the syntax `TYPE : identifier = expression` on first use, where TYPE is `INT`, `FLT`, `STR`, `TNS`, or `FUNC`. Spaces around the colon and equals sign are optional. Subsequent assignments to an existing identifier may omit the type but must preserve the original type. Variables are deallocated only when `DEL(identifier)` is executed.

Inline assignment operator: the built-in `ASSIGN` provides an expression form of assignment, similar to a walrus operator. The general form is `ASSIGN(target, expression)` and it evaluates `expression`, assigns it to `target`, and returns the assigned value. The `target` may be a plain identifier (for example `ASSIGN(x, 1)`) or an indexed assignment target (for example `ASSIGN(tensor[1], 0)` or `ASSIGN(map<"k">, 1)`). If the identifier has not yet been declared, the typed form is required: `ASSIGN(TYPE: name, expression)` declares the identifier's type and performs the assignment in one step. The typed form is only valid for plain identifiers; indexed targets must already exist and follow the same indexed-assignment rules as statement assignments.

Tensor elements can be reassigned with the indexed form `identifier[i1,...,iN] = expression`. The base must be a previously-declared `TNS` binding. The indices must match the tensor's dimensionality, follow the same one-based/negative-index rules as ordinary indexing, and must reference anexisting position. The element's original type cannot change: attempting to store a different type at that position is a runtime error. Indexed assignment mutates the `TNS`.

The language provides `IF`, `ELSEIF`, and `ELSE` constructs for conditional execution. An `IF` statement has the general form `IF(condition){ block }`. Optional chained branches may follow: one or more `ELSEIF(condition){ block }` clauses and an optional terminal `ELSE{ block }` clause. An `ELSEIF` or `ELSE` must immediately follow an `IF` or another `ELSEIF`; otherwise it is a syntax error. At most one `ELSE` may appear in a given chain. Evaluation proceeds by first evaluating the condition of the initial `IF`. If it is non-zero, the associated block executes and the rest of the chain is skipped. Otherwise, the conditions of subsequent `ELSEIF` clauses are evaluated in order until one is non-zero; its block then executes and the chain terminates. If no `IF` or `ELSEIF` condition is satisfied and an `ELSE` is present, the `ELSE` block executes; if there is no `ELSE`, no block in the chain executes.

Exception handling: `TRY` / `CATCH` blocks

The language provides a simple structured exception handling form using `TRY{ ... }CATCH{ ... }` or the alternate `TRY{ ... }CATCH(SYMBOL: name){ ... }` form. A `TRY` block must be immediately followed by a single `CATCH` block (optionally separated by newlines). If a `TRY` is not followed by a `CATCH`, parsing fails. A `CATCH` that does not immediately follow a `TRY` is a syntax error.

Semantics: the interpreter executes the `TRY` block normally. If the `TRY` block completes without a runtime error, execution proceeds to the statement following the `CATCH` block (the `CATCH` block is skipped). If a runtime error (an interpreter-level runtime exception) occurs anywhere during execution of the `TRY` block, normal execution of the `TRY` block stops and the associated `CATCH` block executes. Runtime errors raised inside the `CATCH` block (or propagated from it) behave as normal runtime errors and will be reported or propagated further.

`CATCH(SYMBOL: name)` binding: when using the parameterized `CATCH` form the interpreter creates a temporary symbol `name` (of static type `STR`) visible in the lexical environment of the `CATCH` block whose value is the error message string describing the runtime error that triggered the handler. The temporary symbol shadows any existing binding with the same name for the duration of the `CATCH` block and is removed (or restored to its prior value) immediately after the `CATCH` block completes. The symbol is always a `STR` containing the textual error message; if the handler wishes to inspect richer error metadata it must do so via built-in facilities exposed by the runtime.

Notes and error rules: `TRY`/`CATCH` only intercept interpreter-level runtime errors (for example: undefined identifier, type mismatch, divide-by-zero). `ASYNC` blocks execute on background threads; runtime errors raised inside an `ASYNC` are reported via error hooks and do not synchronously transfer control to nearby `CATCH` blocks in the main thread. Nested `TRY`/`CATCH` works as expected: the innermost enclosing `TRY` with its directly-following `CATCH` handles errors raised within its `TRY` block.

Conditions accept `INT`, `STR`, or `TNS`. `STR` conditions are first converted to `INT` using the `INT` built-in rules (empty -> 0; binary string -> that integer; other non-empty -> 1) before truthiness is checked. A `TNS` condition is true if any of its elements is true by the `INT`/`STR` truthiness rules.

Loops are provided via `WHILE`, `FOR`, and `PARFOR`. A `WHILE` loop has the form `WHILE(condition){ block }`. On each iteration, the condition is evaluated; if it is non-zero, the block executes and control returns to the start of the loop to evaluate the condition again. If the condition evaluates to zero, the loop terminates and execution continues with the next statement.

The `FOR` construct has the form `FOR(counter, target){ block }`, where `counter` is an identifier and `target` is an expression. At loop entry, `target` is evaluated once to a value `T` (must be `INT`), and `counter` is initialized to the `INT` value `0`, creating it as an `INT` if necessary. The loop then repeats: if the current value of `counter` is greater than or equal to `T`, the loop exits; otherwise, the block executes and `counter` is incremented by `1` before the next iteration.

Note on scoping: the loop `counter` is loop-local and does not persist in the enclosing environment after the `FOR` completes (any prior binding with the same name is restored). Any other identifiers that are declared (first assigned with a `TYPE:` declaration) inside the `FOR` body are bound in the enclosing environment (that is, they persist after the loop finishes).

The `PARFOR` construct has the form `PARFOR(counter, target){ block }`. Semantically, the interpreter evaluates `target` once at loop entry (must be `INT`) yielding `T`, then concurrently executes `T` independent iterations indexed from `1` to `T` (inclusive). Each iteration runs the loop `block` with the loop `counter` bound to its iteration index. The interpreter waits for all iterations to complete before proceeding to the statement following the `PARFOR` block. Iteration bodies execute in parallel and may run on different threads; therefore, writes to shared mutable identifiers are subject to race conditions. To avoid unintended races, iteration-local state should be stored in identifiers that are created inside the iteration body or otherwise synchronized by user code. Runtime errors raised inside an iteration are reported and will cause the `PARFOR` to fail after all iterations have joined; the first such error is re-raised to the caller.

Note on scoping: as with `FOR`, the loop `counter` is iteration-local and does not persist in the enclosing environment after the `PARFOR` completes. Identifiers (other than the counter) that are declared inside iteration bodies are nevertheless bound in the enclosing environment; when iterations finish, the interpreter merges those bindings back into the enclosing scope. Because iterations execute concurrently, concurrent writes to the same identifier are subject to race conditions and the final value is implementation-defined (the reference implementation uses a last-writer-wins merge strategy).

  Loop-control semantics inside `PARFOR` differ from sequential loops in the following ways:
  
  - `CONTINUE()` ends the current iteration only; it does not affect other concurrently running iterations.
  
  - `BREAK(n)` terminates the entire `PARFOR`. When a `BREAK` is executed in any iteration, the interpreter signals termination of the `PARFOR`, stops starting any further iterations, waits for currently-running iterations to complete, and then behaves as if `BREAK(n)` had executed at the `PARFOR` site (that is, a `BreakSignal` is propagated to outer loop handlers). Note that because iterations execute concurrently on threads, iterations already executing when the `BREAK` occurred will run to completion unless they themselves check user-level synchronization; `BREAK` prevents additional iterations from starting and ensures the `PARFOR` as a whole terminates as soon as the in-flight iterations finish.

BREAK statement: The language provides a statement form `BREAK(n)` that terminates enclosing loops. When executed inside a loop body (either a `WHILE` or `FOR` loop), `BREAK(n)` breaks out of the innermost `n` loops and resumes execution at the statement following those loops. The argument `n` is evaluated as an integer at runtime and must be strictly positive. If `n ≤ 0` the interpreter raises a runtime error. If `n` is greater than the number of currently-enclosing loops (that is, the statement would escape all surrounding loops), the interpreter raises a runtime error rather than silently terminating the program. Using `BREAK` outside of any loop context similarly results in an error. The exact error type and reporting information are implementation-defined but should be recorded in the state log to make replay and debugging deterministic.

CONTINUE statement: The language provides a statement form `CONTINUE()` that, when executed inside a loop body (either a `WHILE` or `FOR` loop), immediately proceeds to the next iteration of the innermost enclosing loop, skipping any remaining statements in the current iteration. If the current iteration is the final one (that is, no further iterations would occur), `CONTINUE()` has the same effect as executing `BREAK(1)` and thus exits the innermost loop. Using `CONTINUE()` outside of any loop context is a runtime error. Implementations should record the use of `CONTINUE` in the state log so that replay and tracebacks remain deterministic.


## 5. Functions

Functions are defined using the `FUNC` keyword with explicit parameter and return types. The canonical positional-only form is `FUNC name(T1: arg1, T2: arg2, ..., TN: argN):R{ block }`, where each `Tk` and `R` is `INT`, `FLT`, `STR`, `TNS`, or `FUNC`. Parameters may also declare a call-time default value using `Tk: arg = expr`. A parameter without a default is positional; a parameter with a default is keyword-capable. Positional parameters must appear before any parameters with defaults. Defining a function binds `name` to a callable body with the specified typed formal parameters. Function names must not conflict with the names of built-in operators or functions.

In addition to named functions, the language provides an anonymous function literal form `LAMBDA` which constructs a `FUNC` value without binding it to a function name in the global function table. The syntax is `LAMBDA(T1: arg1, T2: arg2, ..., TN: argN):R{ block }`. Parameter typing, default-value rules, call semantics, and return-type rules are the same as for `FUNC`. Evaluating a `LAMBDA` expression captures (closes over) the current lexical environment, producing a first-class `FUNC` value that can be assigned to variables, stored in tensors, passed as an argument, or returned.

A user-defined function is called with the same syntax as a built-in: `callee(expr1, expr2, ..., exprN)`. The callee may be any expression that evaluates to `FUNC`, including identifiers, tensor elements, or intermediate expressions. Calls may supply zero or more positional arguments (left-to-right) followed by zero or more keyword arguments of the form `param=expr`. Keyword arguments can only appear after all positional arguments. At the call site, every positional argument is bound to the next positional parameter; keyword arguments must match the name of a parameter that declared a default value. Duplicate keyword names, supplying too many positional arguments, or providing a keyword for an unknown parameter are runtime errors. If a keyword-capable parameter is omitted from the call, its default expression is evaluated at call time in the function's lexical environment after earlier parameters have been bound. The evaluated default must match the parameter's declared type. Arguments are evaluated left-to-right. The function body executes in a new environment (activation record) that closes over the defining environment. If a `RETURN(v)` statement is executed, the function terminates immediately and yields `v`; the returned value must match the declared return type. If control reaches the end of the body without `RETURN`, the function returns a default value of the declared return type (0 for `INT`, 0.0 for `FLT`, "" for `STR`). Functions whose return type is `TNS` or `FUNC` must execute an explicit `RETURN` of the declared type; reaching the end of the body without returning is a runtime error for `TNS`- or `FUNC`-returning functions.

Because `FUNC` is a first-class type, functions can be assigned to variables, stored inside tensors, passed as arguments, or returned from other functions. Calling `alias()` invokes the function bound to `alias`, while `tns[1]()` invokes the `FUNC` stored in the first tensor slot. Equality compares identity: two `FUNC` values are equal only if they refer to the same function object.

Built-in operators and functions can be viewed as pre-defined functions provided by the runtime environment. User-defined functions share the same call syntax and are distinguished only by their names and bodies. Because of the shared namespace, a user-defined function is not permitted to use any name already reserved for a built-in. Attempting to violate this will raise an exception.


## 6. Variables and Memory Model

A symbol's type may be declared without assigning a value using the form `TYPE : name` (for example `INT: x`). Such a declaration records the name's type but does not create a runtime binding: reading `name` before it has been assigned still yields an undefined-identifier error. A variable is created when it is first assigned with an explicit type annotation `TYPE : name = expression`, or when a value is assigned to a previously-declared name. Subsequent assignments to the same name must match the declared type and may omit the type annotation (for example `x = 1` after `INT: x`). Assigning to an undeclared name without either an inline type annotation or a prior declaration is a runtime error. A variable exists until `DEL(name)` is executed. Referencing a variable that has never been assigned (even if it was previously declared) or that has been deleted is a runtime error.

The language assumes at least a global typed environment mapping identifiers to (type, value) pairs. Function calls create new environments for parameters and local variables, as described in Section 6.2; the precise details of name resolution depend on the chosen scoping rules.

### Pointers

Prefix supports pointer (alias) literals using the `@` prefix. A pointer literal has the form `@name` where `name` is an existing identifier in the visible lexical environment. The `@` token is syntactically distinct from identifiers (see Section 2); it cannot appear inside an identifier name.

- Creation: evaluating `@name` produces a pointer value that refers to the binding named `name`. If `name` is undefined an error is raised. Pointer creation resolves any existing chain of pointers so that the created alias ultimately references the non-pointer target.

- Dereference-on-read: a plain identifier read behaves as if it were dereferenced: if the bound value is a pointer, reads yield the pointed-to value. Thus if `INT: x = 10` and `INT: y = @x`, then reading `y` yields `10`.

- Assignment routing: assigning to a variable whose current binding is a pointer mutates the underlying pointer target rather than replacing the pointer object. Assigning a pointer value that would create a direct self-reference is a runtime error; pointer cycles are detected and rejected when they would create an infinite chain.

- Builtin writeback: when a built-in or function is called with an explicit pointer argument (an argument written using `@`), the runtime may perform a writeback of results into the first pointer argument to support in-place updates (for example `ADD(@x, 1)` increments the pointed-to binding when the builtin semantics specify writeback).

- Freezing rule: creating a new pointer to a binding that is frozen or permanently frozen is forbidden. If the identifier `name` is marked frozen or permafrozen, evaluating `@name` raises a runtime error. An identifier that already has pointers bound to it may still be frozen or permafrozen; freezing prevents any *new* pointer aliasing from being created to that binding until it is thawed.

Pointers are a convenience for aliasing and in-place update patterns; implementations should reflect pointer creation and dereference operations in the state log so that tracebacks and state replay remain deterministic.


## 7. Execution Model and Semantics

The interpreter compiles the source program into an initial machine state, called the seed configuration. This configuration contains at least the parsed (and possibly transformed) program representation, the initial variable environments such as an empty global environment, and an explicit model of I/O and nondeterministic inputs, initially empty.

Execution is driven by a single, fixed, program-independent small-step state-transition function `step`. At each step, `step` takes the current state and produces the next one, encompassing expression evaluation, statement execution, function call and return, and I/O events.

Every state produced during execution is serializable and human-readable. The interpreter maintains a disassembler and log that record the sequence of states visited, the program locations and conditions involved in each control-flow decision, and all I/O actions with their corresponding values. Because I/O and nondeterminism are modeled explicitly within the state, the execution of any program can be deterministically replayed from its seed configuration together with the recorded inputs.


## 8. Standard Library

The standard library is a group of modules for common use cases distributed with the interpreter. at the Prefix directory \lib (or /lib on non-Windows systems).

## 9. Tracebacks and Error Reporting

When a runtime error or exception occurs the interpreter must produce a deterministic, human-readable traceback derived from the state log. The traceback exposes the call stack (frames) at the point of failure and associates each frame with both (1) a compact source-location description and (2) the relevant serialized state sections and state-transformation records from the state log. The goal is to provide developers with the same immediate debugging information that Python's traceback provides but with the additional ability to inspect the exact machine states and the rewrite steps that led to the error for deterministic replay.

### 9.1 Traceback semantics (high level)


`GOTOPOINT` and `GOTO`: Two additional control-flow primitives allow program execution to jump to a dynamically-registered program location. The statement form `GOTOPOINT(n)` evaluates the expression `n` and registers a gotopoint with that identifier at the point where the statement executes. Registration occurs at runtime when the `GOTOPOINT` statement executes; subsequent execution (including execution within loops or after imports) may depend on whether the gotopoint has been registered. Identifiers may be `INT` or `STR`; negative `INT` identifiers are invalid.

The statement form `GOTO(n)` evaluates `n` at runtime and transfers execution to the previously-registered gotopoint whose identifier equals `n`, matching both type and value. If no gotopoint with that identifier has been registered in a scope visible to the jump target, the interpreter raises a runtime error. `GOTO` may jump forward or backward relative to the target gotopoint; jumping to an unregistered identifier is an error. Gotopoints are not restricted to a single lexical block: they are visible across the containing function (or top-level program scope) in which they are defined. Implementations may choose to expose an even broader scope (for example, process-wide), but by default gotopoints registered within a function or at top-level are available to any `GOTO` executed within the same function or top-level code. This change enables cross-block jumps while preserving a clear containment model: a `GOTO` cannot target a gotopoint defined in an unrelated function or module unless the implementation explicitly exposes that mapping.

`GOTO` and `GOTOPOINT` are intended to be low-level primitives and their use can make programs harder to reason about. They are serialized in the stat log like other statements so that execution is fully replayable for debugging and tracing.

- Trigger: a traceback is produced when a runtime error occurs that prevents normal forward execution (for example, an assertion failure, divide by zero, undefined variable reference, executing `RETURN` outside of a function, or any other interpreter-defined runtime error).

- Content: the traceback must list frames in chronological call order from the outermost (earliest) frame to the innermost (where the error occurred), and for each frame include: function name (or `<top-level>` for global code), precise source location, a short excerpt of the offending statement, and identifiers linking to the corresponding states in the state log.

- State linkage: every frame must reference at least one serialized state snapshot from the state log that corresponds to the machine configuration immediately before the failing rewrite step for that frame. The innermost frame must also reference the rewrite (transition) record that produced the error (that is, the failing step).

- Presentation modes: the interpreter must support a concise textual traceback (default) and a verbose mode. The concise mode shows the usual file/line/function stack with a one-line code excerpt per frame and the state-log index. The verbose mode prints, for each frame, the selected state sections (for example: local environment, selected global variables, and the expression evaluation stack) and the full state-transformation record (from_state -> to_state, the rewrite rule name and arguments). The verbose mode is intended for interactive debugging and post-mortem inspection.

### 9.2 Required fields and invariants in the state log

To make tracebacks precise and implementable, the state log (and the machine state representation) must include the following information at every step when relevant:

- `step_index` (integer): monotonically increasing index of the rewrite step in the state log.

- `state_id` (opaque string or integer): stable identifier for the serialized machine state (seed, intermediate, or terminal).

- `source_location` (optional): when a rewrite step is associated with a program location, include a `source_location` record with at least the following fields: `file` (string), `line` (integer), and `statement` (string containing the top-level statement text or canonical snippet).

- `frame_id` (when present): identifier for the active call-frame in that state; frames must be addressable and referable by the traceback generator.

- `env_snapshot` (selectable): a serialized partial view of the state containing bindings for the local variables of the active frame and, where reasonable, a subset of global variables. The interpreter may elide large or sensitive values by policy, but must provide a clear indication when values are elided.

- `rewrite_record`: for each step that performs a state transition, the log must include a record describing the rewrite rule (name, inputs, and parameters), and the `from_state_id` and `to_state_id` pairs.

### 9.3 Traceback textual format (recommended)

The following format is recommended for the concise textual traceback:

```
Traceback (most recent call last):
  File "<file>", line <line>, in <function_or_<top-level>>
    <statement excerpt>
    State log index: <step_index>  State id: <state_id>
```

The final (innermost) frame is then followed by a short error message that includes the failing rewrite (for example: `DivisionByZero`), the rewrite rule name and the `step_index` at which it failed. In verbose mode, each frame block is followed by a labelled `State snapshot: and a `State transformation: section that contain the serialized `env_snapshot` and the `rewrite_record` (including `from_state_id` and `to_state_id`) so that the failure can be reproduced by replaying the states and the associated inputs.

### 9.4 Machine-readable traceback (JSON)

The interpreter must also be able to emit a machine-readable traceback structure suitable for diagnostics tools and editors. The only requirement is that a consumer of the state log can identify which state and which rewrite step correspond to each frame.

### 9.5 Point of origin in source code

The trace must clearly identify the point of origin (the expression or statement that directly caused the error) by including the `source_location` and the `step_index` of the failing rewrite. Implementations should also include the exact token or sub-expression when available (for example, the `DIV(a,0)` call that produced the division-by-zero), and the surrounding source excerpt (at least one line above and below, if available) to make diagnosis easier.

### 9.6 Integrating tracebacks with the disassembler and replay

- The disassembler view must support jumping from a printed traceback to the corresponding state-log entry (`step_index`) and to the reconstructed source location so that a user can inspect the full `from_state` and `to_state` pair and step through the rewrite that produced the error.

- Because the state log records I/O and nondeterminism explicitly, the disassembler/replayer must be able to replay the exact failing step when given the seed configuration and the recorded inputs.

### 9.7 Implementation notes for builders

- The instrumentation needed for tracebacks is primarily bookkeeping: ensure the state log records `step_index`, `state_id`, `frame_id`, and optional `source_location` for each step when appropriate.

- When collecting `env_snapshot` data, prefer including only the local environment of the active frame and a small set of globals to keep tracebacks readable; provide a `--verbose` or similar flag to emit full snapshots.

- Security note: because state snapshots may contain sensitive data, implementations should provide a configurable policy to redact or obfuscate values when generating tracebacks for untrusted logs.

### 9.8 Example (concise textual traceback)

```
Traceback (most recent call last):
  File "prog.pre", line 21, in <top-level>
    result = compute(foo, bar)
    State log index: 121  State id: s_0121
  File "lib.pre", line 88, in compute
    x = DIV(a, b)
    State log index: 123  State id: s_0123
DivisionByZero: attempted to DIV by zero at step_index=123 (rewrite: DIV)
```

This example shows the outer call at the program top-level and the innermost failing call in `compute`. A verbose report would additionally print the `env_snapshot` for `compute` showing `a: 17, b: 0` and the full `rewrite_record` describing the DIV operation that failed.

## 10. Interpreter Use

This section documents how the reference interpreter accepts program input and how to enable verbose tracebacks that include environment snapshots.

- Program argument: the interpreter reads a single *program* argument as its input program. If the `-source` flag is not present, the program argument is interpreted as a path to a source file and the interpreter loads and parses that file. If the `-source` flag is present, the program argument is treated as the source text itself (a string containing the program) and is parsed directly without reading a file.

- Extensions: the interpreter may also accept zero or more *extension* arguments that load Python extension modules before parsing and execution. Extensions may add new operators, new runtime types, and runtime hooks (including custom REPL implementations), but MUST NOT replace or modify existing built-in operators or types.

  - A Python extension is a `.py` file that defines `PREFIX_EXTENSION_API_VERSION = 1` (optional; defaults to 1) and a callable `prefix_register(ext)` entrypoint.
  
  - A pointer file is a `.prex` text file containing one extension path per line. Lines are trimmed; blank lines are ignored; lines beginning with `!` are comments. Relative paths are resolved relative to the `.prex` file's directory; when a referenced path is not found there the interpreter will also try the current working directory and, as a final fallback, the interpreter's own `ext/` subdirectory.
  
  - If a `.prex` file is supplied as an argument, all of the linked extensions are loaded.
  
  - If no explicit extension arguments are provided, the interpreter will automatically look for a pointer file named `.prex` in the current working directory. When a program path is being executed (not when `-source` is used), the interpreter also checks the program's directory for a `.prex` pointer file and will additionally accept a pointer file that shares the program's basename but ends with `.prex` (for example `program.pre` alongside `program.prex`). If any pointer file is found the extensions listed in that pointer file are loaded as if supplied on the command line.
  
  - Extensions are loaded before parsing so that extension-defined type names are recognized in typed assignments and function signatures.
  
  - If the only supplied positional inputs are extensions (and no program is supplied), the interpreter runs the REPL with the loaded extensions.
  
  - Hook surfaces exposed by the reference implementation include:

    - Operators: additional call names dispatched like built-ins. Extensions may opt into module-qualifying all of their operators by defining the module-level flag `PREFIX_EXTENSION_ASMODULE = True`. When an extension sets this flag every operator it registers will be exposed under the extension's name as a dotted prefix (for example, an extension named `mymod` registering `FOO` will expose `mymod.FOO`). This mirrors imported module-qualified bindings and avoids global name collisions.

    - Per-N-steps rules: `every_n_steps(N, handler)` runs the handler after state-log step indices where `step_index % N == 0`.

    - Event-bound rules: `on_event(name, handler)` for the following event names:

      - `program_start(interpreter, program, env)`

      - `program_end(interpreter, exit_code)`

      - `on_error(interpreter, error)`

      - `before_statement(interpreter, stmt, env)` / `after_statement(interpreter, stmt, env)`

      - `before_call(interpreter, name, args, env, location)` / `after_call(interpreter, name, result, env, location)`

    - REPL: extensions may provide a replacement REPL implementation.

- Verbose tracebacks: if the `-verbose` flag is supplied on the command line, tracebacks include the environment snapshots described in Section 10.8. In concise traceback mode the `-verbose` flag causes the interpreter to attach an `env_snapshot` entry to each frame shown; in verbose traceback mode the same flag expands the printed `State snapshot: blocks to include the selected local environment and any small set of globals included by policy. The snapshot contents follow the requirements in Section 10.2 and are suitable for deterministic replay.

Notes:

- The interpreter may support additional flags and a different ordering of arguments; the rules above define the semantics for `argv[1]`, `-source`, and `-verbose` specifically and are intended to be stable for tooling and replay purposes.

- Exit codes: On normal termination (the program completes without an explicit `EXIT()` call and without encountering a runtime error or uncaught exception) the interpreter returns exit code `0` to the operating system. If execution terminates due to a runtime error or uncaught exception the interpreter returns exit code `1`. If the program invokes `EXIT(n)`, the interpreter returns the supplied integer `n` as the process exit code.

Example invocations (illustrative):

- File mode: `prefix program.pre`

- Source-string mode: `prefix -source "foo = INPUT\nPRINT(foo)" -verbose`

- With extensions (file mode): `prefix myext.py program.pre`

- With pointer file: `prefix extensions.prex program.pre`

- REPL / Interactive mode: `prefix` (no program argument), or `prefix myext.py` (extensions only)

## 11. REPL (Interactive Mode)

When the interpreter is invoked without a program path or a `-source` string argument it enters an interactive read–eval–print loop (REPL). The REPL is a convenient development and exploration environment that executes Prefix statements using the same parser, runtime, built-ins, and state-logging semantics as file-mode execution. The following rules describe REPL behaviour:

- Invocation: running `prefix` with no program argument launches the REPL. If one or more extensions are supplied and no program argument is supplied, the interpreter launches a REPL with those extensions loaded; if an extension provides a replacement REPL, that REPL may be used.

- Prompting and input: the REPL presents a primary prompt for new top-level input and a continuation prompt while the user is entering a multi-line block (for example, the body of `FUNC`, `IF`, `WHILE`, or `FOR`).

- Single-line execution: when the user enters a single complete top-level statement (for example `x = 1010` or `PRINT(x)`), the REPL parses and executes that statement immediately and prints any side-effect output. This means `EXIT()` typed as a single-line statement will terminate the REPL immediately and return the supplied exit code (or `0` if omitted), identical to the behaviour when `EXIT()` is executed in a file.

- Multi-line buffering: if a statement begins a block (for example a `FUNC` definition or an `IF(...){` that spans multiple lines), the REPL buffers lines until the block is complete (a blank line may be used to indicate end-of-entry when appropriate). When the buffer is complete the REPL parses and executes the collected statements as a unit.

- Environment persistence: variables, function definitions, and the state logger persist for the duration of the REPL session (that is, top-level bindings remain available across successive inputs until explicitly deleted with `DEL(SYMBOL: name)`). This lets the user incrementally build up a program interactively.

- Deterministic logging and tracebacks: all REPL-executed statements are recorded in the same state log format used for file-mode execution. Errors produce tracebacks in the same concise and verbose modes; the `-verbose` flag causes the REPL to attach `env_snapshot` entries in tracebacks when available.

Notes and examples:

- Start REPL: `prefix`

- Exit via meta-command: type `.exit` or press Ctrl-D (EOF)

- Exit programmatically: `EXIT()` - this immediately terminates the interpreter and returns the specified exit code to the shell, just like in batch execution.


## 12 Operators, Functions, and Statements

This section lists built-in functions, operators and statement signatures, along with a (somewhat) brief description of their behaviour.

Type notation: union signatures such as `INT|STR` restrict arguments to the listed types. `ANY` means "any runtime value"; in the base language this includes `INT`, `STR`, and `TNS`, and when extensions are enabled it also includes extension-defined types (unless a signature explicitly narrows the set).

### Expression syntax

All operators and functions, both built-in and user-defined, share a uniform function-call style syntax of the form `NAME(arg1, arg2, ..., argN)`. The argument list may be empty for certain functions such as `INPUT`. Arguments are separated by commas, and spaces may appear around commas and inside parentheses without changing meaning. Each operator has either a fixed or a variable arity.

Tensor indexing uses the expression form `tensor[i1, i2, ..., iN]`. The number of indices must equal the tensor's dimension count. Indices are one-based; 0 is invalid. Negative indices address from the end of the dimension (for example, -1 is the last element). Attempting to index with an out-of-range position raises a runtime error.

### 12.1 Function / Operator Signatures (expression position)

- `RUN(STR: s)` ; Run a string as a Prefix program within the current environment;

- `ASSERT(ANY: a)` ; crashes if `INT`-style` truthiness of `a` is 0

- `THROW(INT|STR: a1, INT|STR: a2, ...):STR` ; concatenates its arguments using the same rendering rules as `PRINT` and raises a runtime error with the resulting string as the message (rewrite: `THROW`).

- `MAIN():INT` - Returns `1` when the call site belongs to the primary program file (the file passed as the interpreter's first argument, or `<string>` when `-source` is used). Returns `0` when executed from code that came from an `IMPORT` (including nested imports). The result is determined solely by the source file that contains the call expression, not by the caller's call stack.

- `DEL(SYMBOL: x)` ; delete variable `x` from environment

- `ASSIGN(SYMBOL: target, ANY: value):ANY` - Evaluate `value`, assign it to `target`, and return the assigned value. `target` may be a plain identifier or an indexed target (`tensor[...]` or `map<...>`). If the identifier has not been declared, use the typed form `ASSIGN(TYPE: name, value)` to declare and assign in one step. The typed form is only valid for plain identifiers; indexed targets must already exist.

- `EXIT()` or `EXIT(INT:code)` - Requests immediate termination of the interpreter. If an integer `code` is supplied, it is used as the interpreter's process exit code; otherwise `0` is used. Execution stops immediately when `EXIT` is executed (no further statements run), and an entry is recorded in the state log to make deterministic replay possible. Using `EXIT` inside a function terminates the entire program (not just the function).

- `INT(STR: x):INT` ; `STR` -> `INT` using empty/01/other rules; `INT` passthrough

- `STR(INT: x):STR` ; `INT` -> binary-spelled `STR`; `STR` passthrough

- `BYTES(INT: n, endian = "big"):TNS` - Converts a non-negative integer into its byte representation. The optional `endian` parameter controls byte order: if `endian` is `"little"` the result is little-endian (least-significant byte first); if `endian` is `"big"` the result is big-endian (most-significant byte first). The result is a one-dimensional `TNS` whose elements are `INT` values in the range `0..11111111` (0-255 decimal). The tensor length is `max(1, ceil(bit_length(n)/8))`; `BYTES(0)` returns a single zero byte. Supplying a negative integer is a runtime error. Supplying an `endian` value other than `"big"` or `"little"` is a runtime error.

- Binary literal: optional leading `-` (spaces/tabs/CR allowed after the dash) then `{0,1}+`

- String literal: `"` characters `"` (supports escape codes; no newlines)

- `EXIST(SYMBOL: x):INT` ; returns `1` if the identifier `x` exists in the current environment (searching enclosing environments), else `0`. The argument must be an identifier; supplying an expression that is not a plain identifier is a runtime error.

- `ISINT(SYMBOL: x):INT` ; returns `1` if the identifier `x` exists and is of type `INT`, otherwise returns `0`. The argument must be an identifier; supplying any other expression is a runtime error.

- `ISSTR(SYMBOL: x):INT` ; returns `1` if the identifier `x` exists and is of type `STR`, otherwise returns `0`. The argument must be an identifier; supplying any other expression is a runtime error.

- `ISTNS(SYMBOL: x):INT` ; returns `1` if the identifier `x` exists and is of type `TNS`, otherwise returns `0`. The argument must be an identifier; supplying any other expression is a runtime error.

- `TYPE(ANY: obj):STR` ; returns the runtime type name of `obj` as a `STR` - one of `INT`, `FLT`, `STR`, or `TNS` (extension-defined type names are returned unchanged when extensions are enabled).

- `SIGNATURE(SYMBOL: sym):STR` ; returns a textual signature for the identifier `sym`. If `sym` denotes a user-defined function (`FUNC`) the result is formatted in the canonical form used in this specification, for example `FUNC name(T1: arg1, T2: arg2 = default):R`. For other bound symbols the result is `TYPE: symbol` (for example `INT: x`). The argument must be a plain identifier.

- `COPY(ANY: obj):ANY` ; return a shallow copy of `obj`. For `INT`, `FLT`, `STR`, and `FUNC` this produces a same-typed value wrapper. For `TNS` it returns a newly-allocated tensor with the same shape whose elements reference the original element values (shallow). For `MAP` it returns a new map with the same keys and the same value references (shallow).

- `DEEPCOPY(ANY: obj):ANY` ; return a deep copy of `obj`. Recursively copies container values so that the returned value shares no mutable container objects with the original: tensors are duplicated element-by-element and maps are duplicated with their values deep-copied. Primitive values (`INT`, `FLT`, `STR`, and `FUNC`) are treated as atomic and copied by value.

- `SLEN(STR: s):INT` returns the length of the supplied `STR` in characters as an `INT`. The argument must be a `STR`; passing an `INT` raises a runtime error.

- `ILEN(INT: n):INT` returns the length in binary digits of the absolute value of the supplied `INT`. `ILEN(0)` returns 1. The argument must be an `INT`; passing a `STR` raises a runtime error.

### 12.2 Arithmetic (`INT` or `FLT`, no mixing)

- `ADD(INT|FLT: a, INT|FLT: b):INT|FLT` ; `a` + `b`

- `SUB(INT|FLT: a, INT|FLT: b):INT|FLT` ; `a` - `b`

- `MUL(INT|FLT: a, INT|FLT: b):INT|FLT` ; `a` * `b`

- `DIV(INT|FLT: a, INT|FLT: b):INT|FLT` ; `a` / `b`

- `CDIV(INT|FLT: a, INT|FLT: b):INT|FLT` ; ceil(`a` / `b`)

- `POW(INT|FLT: a, INT|FLT: b):INT|FLT` ; `a` ^ `b`

- `ROOT(INT|FLT: x, INT|FLT: n):INT|FLT` ; `n`th root of `x`. No mixing of `INT` and `FLT` is allowed. For `INT` arguments `n` must be non-zero; positive `n` returns the integer nth root (largest integer r with r^n <= x for x >= 0); negative `n` yields an integer result only for `x` equal to `1` or `-1` (reciprocal is integer), and `x < 0` requires odd `n`. For `FLT` arguments the result is `x^(1/n)` (negative `n` allowed); negative `x` is allowed only when `n` is an odd integer. Division by zero is an error.

- `MOD(INT|FLT: a, INT|FLT: b):INT|FLT` ; remainder of `a` / `b`

- `NEG(INT|FLT: a):INT|FLT` ; -`a` (additive inverse)

- `ABS(INT|FLT: a):INT|FLT` ; absolute value of `a`

- `GCD(INT|FLT: a, INT|FLT: b):INT|FLT` ; greatest common divisor of `a` and `b`

- `LCM(INT|FLT: a, INT|FLT: b):INT|FLT` ; least common multiple of `a` and `b`

### 12.3 Coercion arithmetic

- `IADD(INT|FLT: a, INT|FLT: b):INT` ; Convert `a` and `b` to `INT`, return `a` + `b`.

- `ISUB(INT|FLT: a, INT|FLT: b):INT` ; Convert `a` and `b` to `INT`, return `a` - `b`.

- `IMUL(INT|FLT: a, INT|FLT: b):INT` ; Convert `a` and `b` to `INT`, return `a` * `b`.

- `IDIV(INT|FLT: a, INT|FLT: b):INT` ; Convert `a` and `b` to `INT`, return `a` / `b`.

- `IPOW(INT|FLT: a, INT|FLT: b):INT` ; Convert `a` and `b` to `INT`, return `a` ^ `b`.

- `IROOT(INT|FLT: a, INT|FLT: b):INT` ; Convert `a` and `b` to `INT`, return `b`th root of `a`.

- `ISUM(INT|FLT: a1, ..., INT|FLT: aN):INT` ; Convert all arguments to `INT`, return the sum of arguments.

- `IPROD(INT|FLT: a1, ..., INT|FLT: aN):INT` ; Convert `a` and `b` to `INT`, return the product of the arguments.

- `FADD(INT|FLT: a, INT|FLT: b):FLT` ; Convert `a` and `b` to `FLT`, return `a` + `b`.

- `FSUB(INT|FLT: a, INT|FLT: b):FLT` ; Convert `a` and `b` to `FLT`, return `a` - `b`.

- `FMUL(INT|FLT: a, INT|FLT: b):FLT` ; Convert `a` and `b` to `FLT`, return `a` * `b`.

- `FDIV(INT|FLT: a, INT|FLT: b):FLT` ; Convert `a` and `b` to `FLT`, return `a` / `b`.

- `FPOW(INT|FLT: a, INT|FLT: b):FLT` ; Convert `a` and `b` to `FLT`, return `a` ^ `b`.

- `FROOT(INT|FLT: a, INT|FLT: b):FLT` ; Convert `a` and `b` to `FLT`, return `b`th root of `a`.

- `FSUM(INT|FLT: a1, ..., INT|FLT: aN):FLT` ; Convert all arguments to `FLT`, return the sum of arguments.

- `FPROD(INT|FLT: a1, ..., INT|FLT: aN):FLT` ; Convert all arguments to `FLT`, return the product of arguments.

### 12.4 Bitwise / Boolean

- `BAND(INT: a, INT: b):INT` ; bitwise AND

- `BOR(INT: a, INT: b):INT` ; bitwise OR

- `BXOR(INT: a, INT: b):INT` ; bitwise XOR

- `BNOT(INT: a):INT` ; bitwise NOT

- `SHL(INT: a, INT: b):INT` ; shift left

- `SHR(INT: a, INT: b):INT` ; shift right

- `SLICE(INT|STR: a, INT: hi, INT: lo):INT|STR` ; `INT` target -> bit-slice [hi:lo]; `STR` target -> inclusive char-slice counting from the right (index 0 = last char). `TNS` are not accepted.

- `AND(ANY: a1, ..., ANY: aN):INT` ; Boolean AND

- `OR(ANY: a1, ..., ANY: aN):INT` ; Boolean OR

- `XOR(ANY: a1, ..., ANY: aN):INT` ; Boolean XOR

- `NOT(ANY: a):INT` ; Boolean NOT

- `BOOL(ANY: item):INT` ; returns the truthiness of `item` as `INT` (`INT`: non-zero -> `1`, `STR`: non-empty -> `1`, `TNS`: true if any element is true), otherwise `0`, `THR` is true if it is not stopped, `MAP` is true if it has any entries.

### 12.5 Comparisons

- `EQ(ANY: a, ANY: b):INT` ; 1 if `a` == `b` else 0

- `GT(INT|FLT: a, INT|FLT: b):INT` ; 1 if `a` > `b` else 0 (no mixing `INT`/`FLT`)

- `LT(INT|FLT: a, INT|FLT: b):INT` ; 1 if `a` < `b` else 0 (no mixing `INT`/`FLT`)

- `GTE(INT|FLT: a, INT|FLT: b):INT` ; 1 if `a` >= `b` else 0 (no mixing `INT`/`FLT`)

- `LTE(INT|FLT: a, INT|FLT: b):INT` ; 1 if `a` <= `b` else 0 (no mixing `INT`/`FLT`)

### 12.6 Aggregates / Utilities

- `MAX(INT|FLT|STR: a1, ..., INT|FLT|STR: aN):INT|FLT|STR` ; numeric max for `INT`/`FLT`, longest for `STR`; supplying tensors or mixing types is an error

- `MAX(TNS: t1, ..., TNS: tN):INT|FLT|STR` ; flatten the provided tensors and return the largest scalar element according to the normal rules (numeric max for `INT`/`FLT`, longest for `STR`). All tensor elements must be scalar (`INT`, `FLT`, or `STR`) and share the same type. Mixing element types or including `TNS` elements (tensor-of-tensors) is an error.

- `MIN(INT|FLT|STR: a1, ..., INT|FLT|STR: aN):INT|FLT|STR` ; numeric min for `INT`/`FLT`, shortest for `STR`; supplying tensors or mixing types is an error

- `MIN(TNS: t1, ..., TNS: tN):INT|FLT|STR` ; flatten the provided tensors and return the smallest scalar element according to the normal rules (numeric min for `INT`/`FLT`, shortest for `STR`). All tensor elements must be scalar (`INT`, `FLT`, or `STR`) and share the same type. Mixing element types or including `TNS` elements (tensor-of-tensors) is an error.

- `SUM(INT|FLT: a1, ..., INT|FLT: aN):INT|FLT` ; sum of the arguments (no mixing `INT`/`FLT`)

- `LEN(INT|STR: a1, ..., INT|STR: aN):INT` ; number of arguments (N), rejects tensors

- `ALL(ANY: a1, ..., ANY: aN):INT` ; Boolean AND (empty string -> false, non-empty -> true)

- `ANY(ANY: a1, ..., ANY: aN):INT` ; Boolean OR (empty string -> false, non-empty -> true)

- `JOIN(INT|STR: a1, INT|STR: a2, ..., INT|STR: aN):INT|STR` ; `INT` -> concatenate binary spellings with consistent sign; `STR` -> concatenate strings; mixing `INT` and `STR` or supplying tensors raises an error

- `PROD(INT|FLT: a1, ..., INT|FLT: aN):INT|FLT` ; product of the arguments (no mixing `INT`/`FLT`)

### 12.7 String operations

- `UPPER(STR: s):STR` ; `STR` -> uppercase `STR`; error if `s` is `INT`

- `LOWER(STR: s):STR` ; `STR` -> lowercase `STR`; error if `s` is `INT`

- `SPLIT(STR: string, STR: delimiter = " "):TNS` - Splits `string` on the exact substring `delimiter` and returns the parts as a one-dimensional `TNS` of `STR`. The delimiter defaults to a single space. The delimiter must be non-empty; otherwise a runtime error is raised. Consecutive delimiters and trailing delimiters are preserved, so empty-string elements may appear in the result.

- `STRIP(STR: string, STR: remove):STR` - Returns a `STR` formed by removing every occurrence of the substring `remove` from `string`. The `remove` argument must be a non-empty string; supplying an empty `remove` raises a runtime error.

- `REPLACE(STR: string, STR: a, STR: b):STR` - Returns a `STR` formed by replacing every occurrence of the substring `a` in `string` with `b`. The `a` argument must be a non-empty string; supplying an empty `a` raises a runtime error.

- `FLIP(INT|STR: obj):INT|STR` - For `INT` input, returns an `INT` whose binary-digit spelling is the reverse of the absolute-value binary spelling of `obj` (sign is preserved). For `STR` input, returns the character-reversed `STR`.

### 12.8 Tensor operations

- `SHAPE(TNS: tensor):TNS` - Returns the tensor's shape as a 1D `TNS` (vector) of `INT` lengths (one entry per dimension).

- `TLEN(TNS: tensor, INT: dim):INT` - Returns the length of the specified 1-based dimension. Errors if `dim` is out of range.

- `TFLIP(TNS: obj, INT: dim):TNS` - Returns a new `TNS` with the elements along 1-based dimension `dim` reversed. Errors if `dim` is out of range.

- `SCAT(TNS: src, TNS: dst, TNS: ind):TNS` - Returns a copy of `dst` with a rectangular slice replaced by `src`. `ind` must be a 2D tensor of `INT` pairs with shape `[TLEN(dst, 1), 10]` (binary `10` = decimal 2), that is, one `[lo, hi]` row per destination dimension (rank; for example `rank = TLEN(SHAPE(dst), 1)`). Indices are 1-based; negatives follow the tensor indexing rules (for example, `-1` is the last element) and `0` is invalid. For each dimension, the inclusive span `hi - lo + 1` must equal the corresponding `src` dimension length, and all bounds must fall within `dst`. Elements outside the slice are copied from `dst` unchanged.

- `FILL(TNS: tensor, ANY: value):TNS` - Returns a new tensor with the same shape as `tensor`, filled with `value`. The supplied value`s type must match the existing element type at every position.

- `TNS(TNS: shape, ANY: value):TNS` - Creates a new `TNS` with the shape described by a 1D `TNS` of positive `INT` lengths, filled with `value`.

- `TNS(STR: string):TNS` - Converts a `STR` into a 1-D `TNS` of `STR` characters. Each element of the resulting tensor is a `STR` containing a single character from the input string. For example, `TNS("foo")` yields `["f","o","o"]`.

- `CONV(TNS: x, TNS: kernel, INT: stride_w = 1, INT: stride_h = 1, INT: pad_w = 0, INT: pad_h = 0, TNS: bias = []):TNS` - Extended convolution operator.

  - Backward-compatible two-argument form: when called as `CONV(x, kernel)` the operator performs the original N-dimensional discrete convolution and returns a tensor with the same shape as `x`. Requirements and semantics from the original behavior remain unchanged: `kernel` must have the same rank as `x`, every kernel dimension length must be odd (so the kernel has a well-defined center), boundary sampling is clamped to the nearest valid index (replicate padding), and tensor element types must be uniformly `INT` or uniformly `FLT` within each tensor. If both tensors are `INT` the output is `INT`, otherwise the output is `FLT`.

  - 2-D multi-output extension (keyword form): when called with any of the keywords `stride_w`, `stride_h`, `pad_w`, `pad_h`, or `bias`, and when the input `x` is a 3-D WHC tensor (width, height, channels) and `kernel` is a 4-D tensor of shape `[kw, kh, in_c, out_c]`, `CONV` performs a multi-output 2-D convolution. In this mode:

  - `pad_w` / `pad_h` specify zero-padding added to both sides of the width/height dimensions (padding value = 0). The padded input size is `in_w + 2*pad_w` by `in_h + 2*pad_h`.

  - `stride_w` / `stride_h` specify the horizontal and vertical strides (default `1`).

  - Output spatial dimensions are computed as `out_w = floor((p_w - kw) / stride_w) + 1` and `out_h = floor((p_h - kh) / stride_h) + 1` where `p_w = in_w + 2*pad_w`, `p_h = in_h + 2*pad_h`.

  - If `bias` is supplied and is a 1-D `TNS` of length `out_c`, per-output-channel bias is added to each output channel; otherwise no bias is applied.

    - The resulting tensor shape is `[out_w, out_h, out_c]` and numeric typing follows the usual rule: if both input and kernel are `INT` the output is `INT`, otherwise `FLT` (`INT`/`FLT` mixing is allowed and yields `FLT`).

    - Unknown keyword names result in a runtime error; keywords are optional and supplying only `x` and `kernel` preserves original N-D semantics.

  - Note: the two-argument N-D form remains available and unchanged. The keyword extension provides a convenient, backward-compatible way to express common 2-D CNN patterns (stride, explicit zero-padding, and optional bias) without requiring users to compose lower-level primitives manually.

- `IN(ANY: value, TNS: tensor):INT` ; returns `1` if `value` is equal to any element of `tensor` (using the language's equality semantics), otherwise `0`.

- `MADD/MSUB/MMUL/MDIV(TNS: x, TNS: y):TNS` - Elementwise addition, subtraction, multiplication, and division. Shapes must match; all elements must be `INT` or all `FLT` (no mixing). Division by zero is an error.

- `MSUM(TNS: t1, ..., TNS: tN):TNS` - Elementwise sum across tensors. Shapes must match; elements must be all `INT` or all `FLT` (no mixing).

- `MPROD(TNS: t1, ..., TNS: tN):TNS` - Elementwise product across tensors. Shapes must match; elements must be all `INT` or all `FLT` (no mixing).

- `TADD/TSUB/TMUL/TDIV/TPOW(TNS: x, INT|FLT: y):TNS` - Tensor-scalar arithmetic. Tensor elements and scalar must both be `INT` or both be `FLT` (no mixing). Division by zero is an error.

### 12.9 Map operations

- `KEYS(MAP: map): TNS` - Return a 1-D `TNS` containing each of the keys in `map`, in insertion order. Each element of the returned tensor has the native key type (`INT`, `FLT`, or `STR`).

- `VALUES(MAP: map): TNS` - Return a 1-D `TNS` containing each of the values in `map`, in insertion order. Each element of the returned tensor is the stored value and preserves its type (`INT`, `FLT`, `STR`, `TNS`, or `MAP`).

- `KEYIN(INT|FLT|STR: key, MAP: map):INT` - Returns `1` if `map` contains `key` (matching by type and value), otherwise `0`.

- `VALUEIN(ANY: value, MAP: map):INT` - Returns `1` if any value stored in `map` is equal to `value` using the language's equality semantics, otherwise `0`.

- `MATCH(MAP: map, MAP: template, INT: typing = 0, INT: recurse = 0, INT: shape = 0):INT` - Returns `1` if every key in `template` is present in `map`. If `typing` is true, also require that for each matching key the stored value types are identical between `map` and `template`. If `shape` is true, require that for any matching key where either side is a `TNS`, both sides are `TNS` and their shapes are identical. If `recurse` is true, apply these same rules to every `MAP` value nested anywhere within `map` (recursively). On any failure return `0`.

- `INV(MAP: map):MAP` - Return a new map whose key/value pairs are reversed. Each value in `map` becomes a key in the returned map and each original key becomes the corresponding value. All values in `map` MUST be scalar (`INT`, `FLT`, or `STR`) so they can be used as keys; otherwise `INV` raises a runtime error. If `map` contains duplicate values (by key type and value), `INV` raises a runtime error.

### 12.10 Concurrency

- `PARALLEL(TNS: functions):INT` - Execute each element of `functions` in parallel. Each element must evaluate to a `FUNC` value; the interpreter invokes each function with no arguments (in separate worker threads) and waits for all workers to complete. Returns `INT` 0 on success. If any element is not a `FUNC` or any worker raises an error, `PARALLEL` raises a runtime error (rewrite: `PARALLEL`) and the failing worker's error is propagated.

- `PARALLEL(FUNC: f1, FUNC: f2, ...):INT` - Variadic form: accept one or more `FUNC` values as direct arguments. Behaviour is equivalent to the tensor form: each supplied function is invoked in parallel with no arguments and the call waits for completion; returns `INT` 0 on success or raises on error.

- `ASYNC{ block }:THR` - Expression form: start executing `block` asynchronously in a separate thread (while sharing the same namespace) and return a `THR` handle. In statement position, `ASYNC{ block }` is permitted and the returned handle is ignored.

- `STOP(THR: thread):THR` - Cooperatively stop a running thread and mark it finished.

- `AWAIT(THR: thread):THR` - Block until `thread` is finished.

- `PAUSE(THR: thread, FLT: seconds=-1):THR` - Pause execution while preserving the current location. If `seconds` is provided and is >= 0, `thread` is automatically resumed after that duration. Pausing an already-paused thread is a runtime error.

- `RESUME(THR: thread):THR` - Resume a paused thread. Resuming a thread that is not paused is a runtime error.

- `PAUSED(THR: thread):INT` - Returns `INT` 1 if `thread` is paused, otherwise `INT` 0.

- `RESTART(THR: thread):THR` - Reinitialize and start executing the thread again.

### 12.11 Logarithms

- `LOG(INT|FLT: a):INT|FLT` ; floor(log2(a)) for a > 0

- `CLOG(INT: a):INT` ; ceil(log2(a)) for a > 0

### 12.12 Numeric conversions / predicates

- `INT(ANY: a):INT` - Explicit conversion to integer. If `a` is `FLT`, conversion truncates toward zero.

- `FLT(ANY: a):FLT` - Explicit conversion to float.

- `TINT(TNS: obj):TNS` - Convert each scalar element of `obj` to `INT` using the `INT` conversion rules; raises a runtime error if any element cannot be converted.

- `TFLT(TNS: obj):TNS` - Convert each scalar element of `obj` to `FLT` using the `FLT` conversion rules; raises a runtime error if any element cannot be converted.

- `TSTR(TNS: obj):TNS` - Convert each scalar element of `obj` to `STR` using the `STR` conversion rules; raises a runtime error if any element cannot be converted.

- `ISFLT(SYMBOL: name):INT` - 1 if `name` is bound and has type `FLT`, otherwise 0.

### 12.13 Serialization

- `SER(INT|FLT|STR|TNS|MAP|FUNC|THR: obj):STR` ; return a `STR` containing a compact JSON representation of `obj` that encodes runtime type information. Encoding rules (summary): `INT` values are encoded as binary-digit strings (with a leading `-` for negatives), `FLT` values as decimal text via `repr()`, `STR` values as raw strings, `TNS` values as an object with `shape` (list of `INT` lengths) and a flat list of serialized elements, and `MAP` values as a list of key/value entries where keys are encoded with their native type (`INT`, `FLT`, or `STR`) and values are recursively serialized.

  `FUNC` and `THR` values are serialized with enough information to reconstruct them in a new interpreter process:

  - `FUNC` values include an identifier, name, parameter list (including default expressions), return type, the function body AST, and a serialized snapshot of the closure environment. The closure snapshot serializes each bound value via `SER` so that the function can be rehydrated elsewhere.

  - `THR` values include an identifier plus status metadata (paused/finished/stop/state) and, when available, the serialized block AST and environment captured when the thread was created. The underlying OS thread is not serialized.

- `UNSER(STR: obj):INT|FLT|STR|TNS|MAP|FUNC|THR` ; reverse of `SER`. Given a string produced by `SER`, reconstruct the runtime value.

  - For `INT`, `FLT`, `STR`, `TNS`, and `MAP`, reconstruction is exact.

  - For `FUNC`, the interpreter rebuilds the function body and closure environment from the serialized definition so the function can be called in a fresh process.

  - For `THR`, the interpreter reconstructs a `THR` handle with the recorded metadata. The handle is inert: it does not resume the original background task, but supports `TYPE`, `PAUSED`, `STOP`, and `AWAIT` (which returns immediately).

  If the input is not a valid serialization produced by `SER`, `UNSER` raises a runtime error.


### 12.14 Rounding

- `ROUND(FLT: float, STR: mode = "floor", INT: ndigits = 0):FLT` - Round `float` to `ndigits` places right of the radix point (binary places; `ndigits` may be negative). When exactly two arguments are supplied and the second is an `INT`, it is treated as `ndigits` with the mode defaulting to `"floor"`. Modes are:

  - `"floor"` - round toward -∞

  - `"ceiling"` or `"ceil"` - round toward ∞

  - `"zero"` - round toward zero

  - `"logical"` or `"half-up"` - round half away from zero

### 12.15 Module operations:

- `IMPORT(MODULE: name)` or `IMPORT(MODULE: name, SYMBOL: alias)` - Loads another source file and exposes it as a distinct module namespace. When an optional alias identifier is supplied, the imported module's bindings are exposed under the `alias` prefix rather than the module's own name (for example, `IMPORT(mod, ali)` makes `ali.F()` valid while `mod.F()` is not).

  Package imports: Prefix supports package namespaces using `..` as the package separator. The canonical form is `package..subpackage..module`. When `IMPORT(pkg)` is used the interpreter will prefer a package layout and attempt to load `pkg/init.pre` from the referring source's directory (falling back to the interpreter `lib/` directory). If a directory named `pkg` exists but contains no `init.pre` the import raises a clear error. When `IMPORT(pkg..mod)` is used the interpreter resolves to `pkg/mod.pre` (or the corresponding file under `lib/`). When a package directory and a same-named module file both exist in the same search location, the package takes precedence. Items within the package are still imported using their full dotted names (for example, `pkg..mod.FOO`).

- `IMPORT_PATH(STR: path)` - Loads a Prefix module from the absolute filesystem `path` provided as a `STR`. The argument must be an absolute path to a `.pre` source file. The imported module is treated the same as `IMPORT` with respect to parsing, execution isolation, function/module caching, and companion extension loading (companion `<module>.prex` alongside the resolved file and a built-in `ext/<module>.py` are both checked and loaded if present). The module's basename (filename without extension) is used as the module identifier for qualifying exported bindings.

  The first argument must be an identifier naming a module; the interpreter first looks for a file named `<name>.pre` in the same directory as the referring source file. When the referring source is provided via the `-source` string literal mode, the primary search directory is the process's current working directory. If the module file is not found there, the interpreter will additionally attempt to load the file from a `lib` subdirectory located alongside the interpreter implementation (that is, `<interpreter_dir>/lib/<name>.pre`, where `<interpreter_dir>` is the directory containing the interpreter script or executable).

  The imported file is parsed and executed in its own isolated top-level environment on the first import during a given interpreter invocation: top-level assignments and function definitions in the imported module do not directly mutate the caller's environment during execution. During that execution unqualified identifiers (for example, `x` or `helper`) refer to names in the module's own top-level namespace. Qualified identifiers (for example, `other.FOO`) refer only to the dotted names that the module itself has created or imported; those qualified bindings are scoped to the module's namespace.

  After the module finishes executing the first time, the interpreter caches the module's top-level environment and the module-qualified function objects. Subsequent `IMPORT` calls for the same module identifier within the same interpreter process reuse that cached namespace/instance and do not re-execute the module source. Callers importing the same module later will observe the same shared module environment (that is, the same binding objects and the same function objects). By default bindings are exposed under the module's own dotted prefix (`module.FOO`, `module.bar`, etc.); however, if the importer supplied an alias the bindings are instead exposed under the alias prefix (`alias.FOO`, `alias.bar`). Multiple different aliases for the same module identifier will each get their own dotted view into the same cached module instance. If the module imported other modules during its execution, those nested qualified bindings are preserved in the cached namespace and remain accessible via the same dotted paths (for example, `module.other.SYM` or `alias.other.SYM` or `module.alias.SYM`).

  This caching behavior ensures that importing a module multiple times produces the same shared module namespace instance for all importers. The interpreter does not automatically perform cycle detection beyond using the cached instance once execution has completed; careful module design should avoid import cycles where possible.

  When a module is imported, the interpreter also attempts to load any associated runtime extensions so their operators are immediately available to the importer. The interpreter first looks for a companion pointer file named `<module>.prex` next to the resolved module file (or in the interpreter `lib/` fallback) and loads any extensions listed there. If no pointer file is present (or as an additional fallback), the interpreter will also check its built-in `ext/` directory for a single-file extension named `<module>.py` and load it if present. Operators registered by such extensions are attached to the running interpreter at import time and become callable (typically under the module-qualified names they register).

- `EXPORT(SYMBOL: symbol, MODULE: module):INT` - Adds the caller's binding for the identifier `symbol` into the namespace of the imported module named by the identifier `module`. The first argument must be an identifier (not a string literal); its current value in the caller's environment is copied into the imported module's namespace and becomes available as the qualified name `module.symbol` in the caller's environment. The second argument must be an identifier naming a previously-imported module; if the module has not been imported yet, the interpreter raises a runtime error (rewrite: EXPORT). `EXPORT` returns `INT` 0 on success.

### 12.16 File operations:

- `READFILE(STR: path, STR: coding = "UTF-8"):STR` - Reads the file at `path` and returns its contents as a `STR`. Supported `coding` values (case-insensitive) are `UTF-8`, `UTF-8 BOM`, `UTF-16 LE`, `UTF-16 BE`, `ANSI` (Windows-1252 on Windows, Latin-1 elsewhere), `binary` (alias `bin`), and `hexadecimal` (alias `hex`). Text codings decode with replacement on invalid bytes; `UTF-8` tolerates and strips a BOM if present. `binary` returns an 8-bit-per-byte bitstring; `hexadecimal` returns a lowercase hexadecimal string. If the file cannot be opened or read, the interpreter raises a runtime error (rewrite: `READFILE`).

- `WRITEFILE(STR: blob, STR: path, STR: coding = "UTF-8"):INT` - Writes `blob` to `path` using the same `coding` options as `READFILE`. Text codings write in the specified encoding (`UTF-8 BOM` emits a BOM; `ANSI` maps to Windows-1252 on Windows, Latin-1 elsewhere). `binary` expects a bitstring of 0/1 characters whose length is a multiple of 8; `hexadecimal` expects valid hexadecimal. On I/O failure the call returns `INT` 0; invalid coding or malformed binary/hex data raises a runtime error (rewrite: `WRITEFILE`).

- `EXISTFILE(STR: path):INT` - Returns `INT` 1 when a filesystem object exists at `path`, otherwise returns `INT` 0. The argument must be a `STR`.

- `DELETEFILE(STR: path):INT` - Deletes the filesystem object at `path`. If no filesystem object exists at `path`, the interpreter raises a runtime error (rewrite: `DELETEFILE`). Permission errors and other filesystem failures also raise a runtime error (rewrite: `DELETEFILE`). On success `DELETEFILE` returns `INT` 1.

### 12.17 Symbol Freezing:

- `FREEZE(SYMBOL: symbol):INT` - Marks the identifier `symbol` as frozen. The first argument must be an identifier (not a string literal). On success `FREEZE` returns `INT` 0. Once a binding is frozen, any attempt to reassign it (via `=` assignment) or to delete it (`DEL`) raises a runtime error (assign attempts signal rewrite: `ASSIGN`; deletion attempts signal rewrite: `DEL`). `FREEZE` locates the binding in the usual lexical environment chain and freezes that specific binding; if the identifier is undefined, the call raises a runtime error (rewrite: `FREEZE`).

- `THAW(SYMBOL: symbol):INT` - Unfreezes a previously-frozen identifier. The single argument must be an identifier (not a string literal). On success `THAW` returns `INT` 0. If the identifier is undefined the call raises a runtime error (rewrite: `THAW`). If the identifier has been permanently frozen by `PERMAFREEZE`, calling `THAW` raises a runtime error and the binding remains frozen (rewrite: `THAW`). Calling `THAW` on an identifier that is not frozen is a no-op and succeeds.

- `PERMAFREEZE(SYMBOL: symbol):INT` - Permanently freezes the identifier `symbol`. The argument must be an identifier (not a string literal). On success `PERMAFREEZE` returns `INT` 0. A permanently-frozen identifier cannot later be thawed; attempts to call `THAW` on such an identifier raise a runtime error (rewrite: `THAW`). As with `FREEZE`, `PERMAFREEZE` locates the binding in the lexical environment chain and applies the permanent-freeze to that specific binding; if the identifier is undefined the call raises a runtime error (rewrite: `PERMAFREEZE`).

- `FROZEN(SYMBOL: symbol):INT` - Returns `INT` -1 when the named identifier binding is permanently frozen (was previously frozen via `PERMAFREEZE`). If the binding is frozen but not permanently (was frozen via `FREEZE`) the call returns `INT` 1. Otherwise it returns `INT` 0. The single argument must be an identifier (not a string literal). If the identifier is undefined the call returns `INT` 0.

- `PERMAFROZEN(SYMBOL: symbol):INT` - Returns `INT` 1 when the named identifier binding is permanently frozen (was previously frozen via `PERMAFREEZE`), otherwise returns `INT` 0. The single argument must be an identifier (not a string literal). If the identifier is undefined the call returns `INT` 0.

### 12.18 Command Line:

- `INPUT():STR` or `INPUT(STR: s):STR` ; returns a `STR` from the input stream; use `INT` to coerce to an integer when needed. The interpreter prints the prompt inline (so a REPL or other output sink can display it) before reading a line of input. The I/O event is recorded for replay and, when a prompt was supplied, the recorded event includes the prompt text.

- `PRINT(INT|STR: a1, INT|STR: a2, ..., INT|STR: aN):INT` ; prints `INT`/`STR` arguments (side-effect), tensors are rejected; returns `INT` 0

- `CL(STR: command):INT` - Executes the provided `command` string using the host shell and returns the subprocess exit code as an `INT`. The `command` argument must be a `STR`. On a failure to start the subprocess (for example if the system cannot invoke a shell), the interpreter raises a runtime error (rewrite: CL). The call records a `CL` event in the execution I/O log containing the command text and returned exit code, enabling deterministic logging and replay.

- `SHUSH():INT` - Suppresses forwarding of console output to the configured output sink. While shushed, calls that would normally print to the console (for example, `PRINT` and output captured from `CL`) do not forward their text to the interpreter's output sink, though the interpreter continues to record the corresponding I/O events in the execution log for deterministic replay. `INPUT` prompts are still forwarded even when shushed. The `RUN`  operator temporarily disables shushing for the duration of the executed source, so any output produced by code run via `RUN` is forwarded regardless of the current shush state. `SHUSH` takes no arguments and returns `INT` 0 on success.

- `UNSHUSH():INT` - Re-enables forwarding of console output that was previously suppressed by `SHUSH`. Calling `UNSHUSH` clears the shush state so subsequent side-effecting calls that normally produce console output (for example, `PRINT` and output captured from `CL`) are forwarded to the configured output sink. `UNSHUSH` takes no arguments and returns `INT` 0 on success. The interpreter continues to record I/O events in the execution log for deterministic replay; `INPUT` prompts and `RUN` behaviour are unchanged (that is, `INPUT` is always forwarded and `RUN` still temporarily disables shushing while it runs).

### 12.19 Host and environment information:

- `OS():STR` - Returns a short, lowercase ASCII string identifying the host operating-system family. Typical values include `win` for Windows, `linux` for Linux, `macos` for macOS, and `unix` for other Unix-like platforms. The call takes no arguments and returns a `STR`.

- `ARGV():TNS` - Returns the interpreter's argument vector as a one-dimensional `TNS` of `STR`. The tensor's elements are the command-line argument strings supplied to the process, in the same order as the process `argv`, with index 1 holding the interpreter's invocation entry (TNS indices are 1-based).

### 12.20 Control / Function / Statement Signatures (statement position)

- Assignment: `TYPE : identifier = expression` on first use; subsequent assignments omit TYPE but must match the original type. TYPE is `INT`, `FLT`, `STR`, or `TNS`. Tensor elements may be reassigned with `identifier[i1,...,iN] = expression` (indices are 1-based with negative-index support, and the stored type at that element must not change).

- Block: `{ statement1 ... statementN }`

- `IF(condition){ block }` (optional `ELSEIF(condition){ block }` ... `ELSE{ block }`)

- `WHILE(condition){ block }`

- `FOR(counter, INT: target){ block }` ; `counter` initialized to 0, loop until counter >= target

- `PARFOR(counter, INT: target){ block }` ; concurrently execute `target` iterations with `counter` bound to `1..T`. Iteration bodies run in parallel (threaded) and may race on shared mutable identifiers. `CONTINUE()` ends the current iteration only; `BREAK(n)` terminates the entire `PARFOR` (prevents starting further iterations, waits for in-flight iterations to finish, then propagates the `BreakSignal`). Runtime errors raised inside iterations are collected and the first such error is re-raised after all iterations join.

- `FUNC name(T1: arg1, T2: arg2, ..., TN: argN):R{ block }` ; typed function definition with return type R (`INT`, `STR`, or `TNS`); optional defaults use `Tk: arg = expr` and must appear only after all positional parameters. Functions with return type `TNS` must explicitly execute `RETURN(value)`; there is no implicit default tensor value.

- `RETURN(ANY: a)` ; return from function with value `a`

- `POP(SYMBOL: x)` - Convenience statement combining `RETURN` and `DEL`: when executed inside a function body it retrieves the current value of the identifier `x`, deletes the binding `x` from the environment (so subsequent references are an error), and returns the retrieved value to the caller. Using `POP` outside of a function is a runtime error.

- `BREAK(INT: n)` ; break out of the innermost `n` enclosing loops; raises a runtime error if `n` ≤ 0 or if `n` is greater than the current loop nesting depth

- `CONTINUE()` ; skip remaining statements in the innermost loop iteration and proceed to the next iteration; if used in the last iteration it acts like `BREAK(1)`. Using `CONTINUE()` outside of a loop is a runtime error.

- `GOTOPOINT(INT|STR: n)` ; register a gotopoint with identifier `n` at this statement's location (identifier may be `INT` or `STR`) (n evaluated at runtime). Gotopoints are visible across the containing function or top-level scope rather than being restricted to a single lexical block.

- `GOTO(INT|STR: n)` ; jump to a previously-registered gotopoint with identifier `n` (`INT` or `STR`) within the same function or top-level scope; runtime error if not registered in that scope

- `ASYNC{ block }` ; execute `block` asynchronously in a separate thread (while sharing the same namespace); the caller continues executing immediately without waiting for the async block to complete. Any uncaught errors in the async block are logged to the interpreter's error log but do not affect the caller. When used in expression position, `ASYNC{ block }` evaluates to a `THR` handle. If the expression is used as an argument to a surrounding call expression, the worker thread's start is deferred until that enclosing call completes so that the callee may operate on the `THR` (for example, `PAUSE` or `STOP`) before the worker runs; in statement position the worker starts immediately and the returned handle is ignored.

- `THR(SYMBOL: symbol){ block }` ; execute `block` asynchronously in a separate thread and bind the identifier `symbol` (static type `THR`) to the thread handle.

- `TRY{ block }CATCH{ block }` ; execute `block` in the `TRY` and, if an interpreter-level runtime error occurs during the `TRY` block, stop the `TRY` and execute the directly-following `CATCH` block. If no error occurs, the `CATCH` block is skipped.

- `TRY{ block }CATCH(SYMBOL: name){ block }` ; like the previous form but bind a temporary `STR` symbol `name` visible inside the `CATCH` block containing the error message. The temporary symbol shadows any existing binding for `name` and is restored or removed after the `CATCH` block completes.

### 12.21 Notes

- Built-ins are statically typed. Boolean contexts treat `INT` 0 as false and non-zero as true; `FLT` is false when 0.0 and true otherwise; `STR` is false when empty and true when non-empty unless a rule explicitly converts via `INT`. A `TNS` is true if any element is true by those rules.

- Argument evaluation order: left-to-right.

- User-defined functions use the same call syntax as built-ins; keyword arguments are permitted only after positional arguments and only for parameters that declare defaults. Built-ins reject keyword arguments except that `READFILE` and `WRITEFILE` accept an optional `coding=` keyword. When a keyword parameter is omitted, its default expression is evaluated at call time in the function's defining environment.


  </script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function(){
      const md = document.getElementById('md').textContent;
      const rendered = marked.parse(md);
      const container = document.getElementById('content');
      container.innerHTML = rendered;

      // Ensure predictable heading IDs so TOC fragment links work.
      // Slug function: lowercase, remove punctuation except digits/letters/spaces/-,
      // collapse spaces to hyphens.
      function slugify(text) {
        return text.trim().toLowerCase()
          .replace(/<[^>]+>/g, '')
          .replace(/[^a-z0-9\s-]/g, '')
          .replace(/\s+/g, '-');
      }

      const headings = container.querySelectorAll('h1,h2,h3,h4,h5,h6');
      headings.forEach(h => {
        if (!h.id || h.id.trim() === '') {
          h.id = slugify(h.textContent || h.innerText || '');
        }
      });
    });
  </script>
</body>
</html>
