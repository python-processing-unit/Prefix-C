# Image loading helpers for Prefix
# Backed by ext/image.py (stdlib-only, prefers Windows GDI+).
#
# API (operators provided by the model/extension):
# LOAD_PNG(STR: path):TNS[width,height,[r,g,b,a]]
# LOAD_JPEG(STR: path):TNS[width,height,[r,g,b,a]]
# LOAD_BMP(STR: path):TNS[width,height,[r,g,b,a]]
# LOAD(STR: path):TNS[height,width,[r,g,b,a]]  # auto-detects format by extension
# SAVE_PNG(TNS: img, STR: path, INT: compression_level)
# SAVE_JPEG(TNS: img, STR: path, INT: compression_level)
# SAVE_BMP(TNS: img, STR: path)
# POLYGON(TNS:img, TNS:points[[x,y]...], TNS:color[r,g,b,a], INT:fill=1, INT:thickness=1):TNS
# RECT(TNS: img, INT: x, INT: y, INT: width, INT: height, TNS: color[r,g,b,a], INT: fill = 1, INT: thickness = 1):TNS  # wraps POLYGON
# ELLIPSE(TNS: img, TNS: center, INT: rx, INT: ry, TNS: color[r,g,b,a], INT: fill = 1, INT: thickness = 1):TNS
# SQUARE(TNS: img, INT: x, INT: y, INT: size, TNS: color, INT: fill, INT: thickness):TNS
# CIRCLE(TNS: img, TNS: center, INT: radius, TNS: color, INT: fill, INT: thickness):TNS
# WIDTH(TNS: img):INT
# HEIGHT(TNS: img):INT
# CHANNELS(TNS: img):INT
# R(TNS: img):TNS
# G(TNS: img):TNS
# B(TNS: img):TNS
# A(TNS: img):TNS
# PIXEL(TNS: img, INT: x, INT: y):TNS
# PIXEL_R(TNS: img, INT: x, INT: y):INT
# PIXEL_G(TNS: img, INT: x, INT: y):INT
# PIXEL_B(TNS: img, INT: x, INT: y):INT
# PIXEL_A(TNS: img, INT: x, INT: y):INT
# THRESHHOLD_A(TNS:img, INT:a, TNS:color=[0,0,0,0]):TNS
# THRESHHOLD_R(TNS:img, INT:r, TNS:color=[0,0,0,0]):TNS
# THRESHHOLD_G(TNS:img, INT:g, TNS:color=[0,0,0,0]):TNS
# THRESHHOLD_B(TNS:img, INT:b, TNS:color=[0,0,0,0]):TNS
# FLIP_V(TNS: img):TNS
# FLIP_H(TNS: img):TNS
# INVERT(TNS: img):TNS
# SCALE(TNS: src, FLT: scale_x, FLT: scale_y, INT: antialiasing = 1):TNS
# RESIZE(TNS: img, INT: new_width, INT: new_height, INT: antialiasing = 1):TNS
# CROP(TNS:img, TNS:corners[[tl_x,tl_y],[tr_x,tr_y],[bl_x,bl_y],[br_x,br_y]]):TNS
# ROTATE(TNS: img, FLT: degrees):TNS
# BLIT(TNS: src, TNS: dest, INT: x, INT: y, INT: mixalpha = 1):TNS
# GRAYSCALE(TNS: img):TNS  # three-channel grayscale (rgb=luminance, alpha preserved)
# REPLACE_COLOR(TNS: img, TNS: target_color, TNS: replacement_color):TNS
# BLUR(TNS: img, INT: radius):TNS  # gaussian blur with integer radius
# EDGE(TNS: img):TNS  # difference-of-gaussians edge detector
# CELLSHADE(TNS: img, TNS: colors):TNS  # map pixels to nearest palette color
# SHOW(TNS: img):INT  # saves to temp file and opens with default viewer (Windows only)
#
# The returned tensor layout is [column][row][channel] (width, height, channel)
# in user code. Channels are ordered r,g,b,a and values are 0..255.

IMPORT(path)

FUNC LOAD(STR: img_path):TNS{
    STR: ext = path.EXTNAME(img_path)
    IF(EQ(ext, "png")){
        RETURN(image.LOAD_PNG(img_path))
    } ELSEIF (OR(EQ(ext, "jpg"),EQ(ext, "jpeg"))){
        RETURN(image.LOAD_JPEG(img_path))
    } ELSEIF (EQ(ext, "bmp")){
        RETURN(image.LOAD_BMP(img_path))
    } ELSE {
        THROW("Unsupported image format: ",ext)
    }
}

FUNC WIDTH(TNS: img):INT{
    RETURN(TLEN(img, 1))
}

FUNC HEIGHT(TNS: img):INT{
    RETURN(TLEN(img, 10))
}

FUNC CHANNELS(TNS: img):INT{
    RETURN(TLEN(img, 11))
}

FUNC R(TNS: img):TNS{
    RETURN(img[*, *, 1])
}

FUNC G(TNS: img):TNS{
    RETURN(img[*, *, 10])
}

FUNC B(TNS: img):TNS{
    RETURN(img[*, *, 11])
}

FUNC A(TNS: img):TNS{
    RETURN(img[*, *, 100])
}

FUNC PIXEL(TNS: img, INT: x, INT: y):TNS{
    RETURN(img[x,y,*])
}

FUNC PIXEL_R(TNS: img, INT: x, INT: y):INT{
    RETURN(img[x,y,1])
}

FUNC PIXEL_G(TNS: img, INT: x, INT: y):INT{
    RETURN(img[x,y,10])
}

FUNC PIXEL_B(TNS: img, INT: x, INT: y):INT{
    RETURN(img[x,y,11])
}

FUNC PIXEL_A(TNS: img, INT: x, INT: y):INT{
    RETURN(img[x,y,100])
}

FUNC FLIP_V(TNS: img):TNS{
    RETURN(TFLIP(img, 1))
}

FUNC FLIP_H(TNS: img):TNS{
    RETURN(TFLIP(img, 10))
}

FUNC RECT(TNS: img, INT: x, INT: y, INT: width, INT: height, TNS: color, INT: fill, INT: thickness):TNS{
    TNS: pts = [ ^
        [x, y], ^
        [ADD(x, SUB(width, 1)), y], ^
        [ADD(x, SUB(width, 1)), ADD(y, SUB(height, 1))], ^
        [x, ADD(y, SUB(height, 1))], ^
        [x, y] ^
    ]
    RETURN(image.POLYGON(img, pts, color, fill, thickness))
}

FUNC RECTANGLE(TNS: img, INT: x, INT: y, INT: width, INT: height, TNS: color, INT: fill, INT: thickness):TNS{
    RETURN(RECT(img, x, y, width, height, color, fill, thickness))
}

FUNC FILL_RECT(TNS: img, INT: x, INT: y, INT: width, INT: height, TNS: color):TNS{
    RETURN(RECT(img, x, y, width, height, color, 1, 1))
}

FUNC FILL_ELLIPSE(TNS: img, TNS: center, INT: rx, INT: ry, TNS: color):TNS{
    RETURN(image.ELLIPSE(img, center, rx, ry, color, 1, 1))
}
 
FUNC SQUARE(TNS: img, INT: x, INT: y, INT: size, TNS: color, INT: fill, INT: thickness):TNS{
    RETURN(RECT(img, x, y, size, size, color, fill, thickness))
}

FUNC CIRCLE(TNS: img, TNS: center, INT: radius, TNS: color, INT: fill, INT: thickness):TNS{
    RETURN(image.ELLIPSE(img, center, radius, radius, color, fill, thickness))
}

FUNC SHOW(TNS: img):INT{
    # Save the image to the provided path and open it with the system default
    # viewer on Windows. `img_path` is treated as the target file path.
    STR: img_path = "C:/Windows/Temp/tmp_img.png"
    image.SAVE_PNG(img, img_path, 0)
    # ShellExecuteW(hwnd, operation, file, params, dir, showcmd)
    # Use NULL hwnd (0), operation "open", empty params and dir, showcmd=1
    win32.WIN_CALL("shell32", "ShellExecuteW", "PSSSSI", "P", 0, "open", img_path, "", "", 1)
    DEL(img_path)
    RETURN(0)
}