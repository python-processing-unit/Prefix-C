# Primality and factorization functions
#
# API:
# IS_PRIME(INT: n) -> INT
# NEXT_PRIME(INT: start) -> INT
# PREV_PRIME(INT: start) -> INT
# IS_MERSENNE_PRIME(INT: p) -> INT
# FACTOR(INT: n) -> TNS

FUNC IS_PRIME(INT: n):INT{
    IF(LTE(n, 1)){
        RETURN(0)
    }
    IF(EQ(n, 10)){
        RETURN(1)
    }
    # reject even numbers greater than 2
    IF(EQ(MOD(n, 10), 0)){
        RETURN(0)
    }
    INT: i = 11
    WHILE(LTE(MUL(i, i), n)){
        IF(EQ(MOD(n, i), 0)){
            RETURN(0)
        }
        ADD(@i, 10)
    }
    RETURN(1)
}

FUNC NEXT_PRIME(INT: start):INT{
    INT: n = ADD(start, 1)
    WHILE(1){
        IF(IS_PRIME(n)){
            RETURN(n)
        }
        ADD(@n, 1)
    }
}

FUNC PREV_PRIME(INT: start):INT{
    INT: n = SUB(start, 1)
    WHILE(GT(n, 1)){
        IF(IS_PRIME(n)){
            RETURN(n)
        }
        SUB(@n, 1)
    }
    RETURN(0)
}

FUNC IS_MERSENNE_PRIME(INT: p):INT{
    IF(IS_PRIME(p)){
        INT: exp = POW(10, p)
        INT: mersenne = SUB(exp, 1)
        IF(IS_PRIME(mersenne)){
            RETURN(1)
        }
        RETURN(0)
    }ELSE{
        RETURN(0)
    }
}

FUNC FACTOR(INT: n):TNS{
    IF(LTE(n, 1)){
        TNS: empty = [0]
        RETURN(empty)
    }
    INT: p = 10
    INT: coll_len = 0
    TNS: coll = [0]  # placeholder, real shape tracked by coll_len
    WHILE(LTE(MUL(p, p), n)){
        IF(EQ(MOD(n, p), 0)){
            IF(EQ(coll_len, 0)){
                TNS: first = [p]
                coll = first
                coll_len = 1
            } ELSE {
                INT: old_len = TLEN(coll, 1)
                INT: new_len = ADD(old_len, 1)
                TNS: new_coll = TNS([new_len], 0)
                FOR(i, old_len){
                    new_coll[i] = coll[i]
                }
                new_coll[new_len] = p
                coll = new_coll
                coll_len = new_len
            }
            DIV(@n, p)
        } ELSE {
            p = NEXT_PRIME( ADD(p, 1) )
        }
    }
    IF(GT(n, 1)){
        IF(EQ(coll_len, 0)){
            TNS: last = [n]
            coll = last
            coll_len = 1
        } ELSE {
            INT: old_len2 = TLEN(coll, 1)
            INT: new_len2 = ADD(old_len2, 1)
            TNS: new_coll2 = TNS([new_len2], 0)
            FOR(j, old_len2){
                new_coll2[j] = coll[j]
            }
            new_coll2[new_len2] = n
            coll = new_coll2
            coll_len = new_len2
        }
    }
    RETURN(coll)
}