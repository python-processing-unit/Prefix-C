# ChaCha20-based cryptographically secure pseudorandom number generator
#
# API:
# SEED(INT: seed) -> INT
# NEXT() -> INT
# RANGE(INT: max) -> INT
# RANGE_MIN_MAX(INT: min, INT: max) -> INT

INT: MASK32 = SUB( POW(10,100000), 1 )  # 2^32-1

# ChaCha20 constants ("expand 32-byte k")
MAP: CH_CONST = < ^
    0 = 01100001011100000111000001100101, ^
    1 = 00110011001000000110010001101110, ^
    10 = 01111001011000100010110100110010, ^
    11 = 01101011001000000110010101110100 ^
>

TNS: ch_key = TNS([1000], 0)  # 8 words
TNS: ch_nonce = [0, 0, 0] # use literals for short TNS
INT: ch_counter = 0
TNS: ch_buf = TNS([10000], 0) # 16 words
INT: ch_buf_pos = TLEN(ch_buf, 1)  # set to buffer length to force refill

FUNC ROTL32(INT: x, INT: n):INT{
    INT: x32 = BAND(x, MASK32)
    INT: left = BAND(SHL(x32, n), MASK32)
    INT: right = SHR(x32, SUB(100000, n))  # 32 - n
    RETURN( BAND(BOR(left, right), MASK32) )
}

FUNC QR(TNS: s, INT: ia, INT: ib, INT: ic, INT: id):INT{
    INT: a = s[ia]
    INT: b = s[ib]
    INT: c = s[ic]
    INT: d = s[id]

    a = BAND( ADD(a, b), MASK32 )
    d = ROTL32( BXOR(d, a), 10000 )   # 16
    c = BAND( ADD(c, d), MASK32 )
    b = ROTL32( BXOR(b, c), 1100 )    # 12
    a = BAND( ADD(a, b), MASK32 )
    d = ROTL32( BXOR(d, a), 1000 )    # 8
    c = BAND( ADD(c, d), MASK32 )
    b = ROTL32( BXOR(b, c), 111 )     # 7

    s[ia] = a
    s[ib] = b
    s[ic] = c
    s[id] = d
    RETURN(0)
}

FUNC CHACHA_BLOCK():INT{
    TNS: k = ch_key
    TNS: n = ch_nonce
    TNS: state = [ ^
        CH_CONST<0>, ^
        CH_CONST<1>, ^
        CH_CONST<10>, ^
        CH_CONST<11>, ^
        k[1], ^
        k[10], ^
        k[11], ^
        k[100], ^
        k[101], ^
        k[110], ^
        k[111], ^
        k[1000], ^
        ch_counter, ^
        n[1], ^
        n[10], ^
        n[11] ^
    ]
    FOR(i, 1010){  # 10 double-rounds
        QR(state, 1, 101, 1001, 1101)
        QR(state, 10, 110, 1010, 1110)
        QR(state, 11, 111, 1011, 1111)
        QR(state, 100, 1000, 1100, 10000)

        QR(state, 1, 110, 1011, 10000)
        QR(state, 10, 111, 1100, 1101)
        QR(state, 11, 1000, 1001, 1110)
        QR(state, 100, 101, 1010, 1111)
    }

    ch_buf[1] = BAND( ADD(state[1], CH_CONST<0>), MASK32 )
    ch_buf[10] = BAND( ADD(state[10], CH_CONST<1>), MASK32 )
    ch_buf[11] = BAND( ADD(state[11], CH_CONST<10>), MASK32 )
    ch_buf[100] = BAND( ADD(state[100], CH_CONST<11>), MASK32 )
    ch_buf[101] = BAND( ADD(state[101], k[1]), MASK32 )
    ch_buf[110] = BAND( ADD(state[110], k[10]), MASK32 )
    ch_buf[111] = BAND( ADD(state[111], k[11]), MASK32 )
    ch_buf[1000] = BAND( ADD(state[1000], k[100]), MASK32 )
    ch_buf[1001] = BAND( ADD(state[1001], k[101]), MASK32 )
    ch_buf[1010] = BAND( ADD(state[1010], k[110]), MASK32 )
    ch_buf[1011] = BAND( ADD(state[1011], k[111]), MASK32 )
    ch_buf[1100] = BAND( ADD(state[1100], k[1000]), MASK32 )
    ch_buf[1101] = BAND( ADD(state[1101], ch_counter), MASK32 )
    ch_buf[1110] = BAND( ADD(state[1110], n[1]), MASK32 )
    ch_buf[1111] = BAND( ADD(state[1111], n[10]), MASK32 )
    ch_buf[10000] = BAND( ADD(state[10000], n[11]), MASK32 )

    RETURN(0)
}

FUNC REFILL_BUF():INT{
    CHACHA_BLOCK()
    ch_buf_pos = 0
    ch_counter = BAND( ADD(ch_counter, 1), MASK32 )
    RETURN(0)
}

FUNC DERIVE_KEY_AND_NONCE(INT: seed):INT{
    INT: s = BAND(seed, MASK32)
    FOR(i, 1000){  # 8 key words (1000 == 8)
        s = BAND( ADD( MUL(s, ^
            01000001110001100100111001101101), ^
            00000000000000000011000000111001 ), ^
            MASK32 ^
        )
        ch_key[i] = s
    }
    FOR(j, 11){  # 3 nonce words (11 == 3)
        s = BAND( ADD( MUL(s, ^
            01000001110001100100111001101101), ^
            00000000000000000011000000111001 ), ^
            MASK32 ^
        )
        ch_nonce[j] = s
    }
    RETURN(0)
}

FUNC SEED(INT: seed):INT{
    DERIVE_KEY_AND_NONCE(seed)
    ch_counter = 0
    ch_buf = TNS([10000], 0)
    ch_buf_pos = TLEN(ch_buf, 1)  # set to buffer length to force refill
    RETURN(ch_counter)
}

FUNC NEXT():INT{
    IF( GTE(ch_buf_pos, TLEN(ch_buf, 1)) ){  # buffer length
        REFILL_BUF()
    }
    INT: v = ch_buf[ ADD(ch_buf_pos, 1) ]
    ch_buf_pos = ADD(ch_buf_pos, 1)
    RETURN(v)
}

FUNC RANGE(INT: max):INT{
    ASSERT( GT(max, 0) )
    RETURN( MOD(NEXT(), max) )
}

FUNC RANGE_MIN_MAX(INT: min, INT: max):INT{
    ASSERT( LTE(min, max) )
    INT: range = SUB(max, min)
    IF( EQ(range, 0) ){ RETURN(min) }
    ASSERT( GT(range, 0) )
    INT: offset = RANGE(range)
    RETURN( ADD(offset, min) )
}