IMPORT(prng)
IMPORT(csprng)
IMPORT(prime)
IMPORT(numbers)
IMPORT(path)
IMPORT(image)
IMPORT(gui)
IMPORT(waveforms)
IMPORT(stats)
IMPORT(diff)

FUNC BUILTIN_TESTS():INT{
    PRINT("Running built-in tests...")
    # --- Literal formats ---
    # Binary integer literals (unsigned and signed)
    INT: i0 = 0
    INT: i1 = 1
    INT: i5 = 101   # 5
    INT: i_neg = -101   # -5 (signed literal)
    ASSERT( EQ(i0, 0) )
    ASSERT( EQ(i1, 1) )
    ASSERT( EQ(i5, 101) )
    ASSERT( EQ(i_neg, -101) )
    DEL(i0)
    DEL(i1)
    DEL(i5)
    DEL(i_neg)

    # Floating-point binary fixed-point forms
    FLT: f_half = 0.1    # 0.5
    FLT: f_quarter = 0.01 # 0.25
    FLT: f_threeq = 0.11  # 0.75
    ASSERT( EQ( ADD(f_half, f_quarter), f_threeq ) )
    DEL(f_half)
    DEL(f_quarter)
    DEL(f_threeq)

    # String literal escapes
    STR: s_esc = "Line\\nTab\\tQuote\""
    ASSERT( EQ( REPLACE(s_esc, "\\n", "\n"), REPLACE(s_esc, "\\n", "\n") ) )
    # simple equality check for literal with escapes
    DEL(s_esc)

    # Line continuation (caret ^) inside a tensor literal and index expressions
    TNS: cont = [ ^
        [1, 10, 11], ^
        [100, 101, 110] ^# carets allowed before code notes
    ]
    ASSERT( EQ( TLEN(cont, 1), 10 ) )
    DEL(cont)

    # Semicolon as newline alias
    INT: sc1 = 1010; INT: sc2 = 11; ASSERT( EQ( ADD(sc1, sc2), 1101 ) )
    DEL(sc1)
    DEL(sc2)

    # --- Numeric operators (INT and FLT where applicable) ---
    INT: a = 1010   # 10
    INT: b = 111    # 7
    ASSERT( EQ( ADD(a, b), 10001 ) )   # 10+7=17 (10001)
    ASSERT( EQ( SUB(a, b), 11 ) )      # 10-7=3
    ASSERT( EQ( MUL(a, b), 1000110 ) ) # 10*7=70 (1000110)
    ASSERT( EQ( DIV(a, b), 1 ) )       # floor(10/7)=1
    ASSERT( EQ( MOD(a, b), 11 ) )     # 10%7=3
    ASSERT( EQ( NEG(b), -111 ) )
    DEL(a)
    DEL(b)

    # Power/root/abs/gcd/lcm where available
    INT: p = 11   # 3
    INT: q = 10   # 2
    # 3^2 = 9 -> binary 1001
    ASSERT( EQ( POW(p, q), 1001 ) )
    DEL(p)
    DEL(q)

    # Coercing arithmetic (I*/F* operators)
    ASSERT( EQ( IADD(1, 0.1), 1 ) )          # 1 + int(0.5) = 1
    ASSERT( EQ( ISUB(10, 0.1), 10 ) )        # 2 - 0 = 2
    ASSERT( EQ( IMUL(11, 0.1), 0 ) )         # 3 * 0 = 0
    ASSERT( EQ( IDIV(101, 10), 10 ) )        # 5 // 2 = 2
    ASSERT( EQ( IPOW(11, 10), 1001 ) )       # 3^2 = 9
    ASSERT( EQ( IROOT(1000, 11), 10 ) )      # cube_root(8)=2
    ASSERT( EQ( ISUM(1, 10, 0.1), 11 ) )     # 1 + 2 + 0 = 3
    ASSERT( EQ( IPROD(1, 10, 11), 110 ) )    # 1*2*3=6

    ASSERT( EQ( FADD(1, 10), 11.0 ) )        # 1 + 2 = 3.0
    ASSERT( EQ( FSUB(11, 10), 1.0 ) )        # 3 - 2 = 1.0
    ASSERT( EQ( FMUL(11, 10), 110.0 ) )      # 3 * 2 = 6.0
    ASSERT( EQ( FDIV(101, 10), 10.1 ) )      # 5 / 2 = 2.5
    ASSERT( EQ( FPOW(11, 10), 1001.0 ) )     # 3^2 = 9.0
    ASSERT( EQ( FROOT(1000, 11), 10.0 ) )    # cube_root(8)=2.0
    ASSERT( EQ( FSUM(1, 10, 0.1), 11.1 ) )   # 1 + 2 + 0.5 = 3.5
    ASSERT( EQ( FPROD(1, 10, 11), 110.0 ) )  # 1*2*3=6.0

    # --- Bitwise and shift-like ops ---
    INT: x = 1010   # 10
    INT: y = 110    # 6
    # Use explicit bitwise builtins: BAND/BOR/BXOR, BNOT, SHL/SHR
    ASSERT( EQ( BAND(x, y), 10 ) )
    ASSERT( EQ( BOR(x, y), 1110 ) )
    ASSERT( EQ( BXOR(x, y), 1100 ) )
    DEL(x)
    DEL(y)

    # --- Comparison and logical operators ---
    ASSERT( EQ( GT(101, 11), 1 ) )   # 5 > 3
    ASSERT( EQ( LT(11, 101), 1 ) )   # 3 < 5
    ASSERT( EQ( GTE(101, 101), 1 ) )
    ASSERT( EQ( LTE(11, 11), 1 ) )
    ASSERT( EQ( EQ(101, 101), 1 ) )
    ASSERT( EQ( EQ(101, 11), 0 ) )
    ASSERT( EQ( NOT(EQ(101, 11)), 1 ) )
    # Logical combinators
    ASSERT( EQ( AND(1, 1), 1 ) )
    ASSERT( EQ( AND(1, 0), 0 ) )
    ASSERT( EQ( OR(1, 0), 1 ) )
    ASSERT( EQ( OR(0, 0), 0 ) )
    ASSERT( EQ( NOT(0), 1 ) )
    ASSERT( EQ( NOT(1), 0 ) )

    # --- Strings: JOIN, SUBSTR, CONCAT, LENGTH (if available) ---
    STR: sa = "foo"
    STR: sb = "bar"
    STR: joined = JOIN(sa, sb)
    ASSERT( EQ( joined, "foobar" ) )
    # Join with separator
    STR: joined_sp = JOIN(sa, "-", sb)
    ASSERT( EQ( joined_sp, "foo-bar" ) )
    DEL(sa)
    DEL(sb)
    DEL(joined)
    DEL(joined_sp)

    # --- Tensors: constructors, TLEN, indexing, sets ---
    # Tensors: 4 elements -> TLEN(...,1) == 100
    TNS: t1 = [1, 10, 11, 100]
    ASSERT( EQ( TLEN(t1, 1), 100 ) )
    # element access
    ASSERT( EQ( t1[1], 1 ) )
    ASSERT( EQ( t1[10], 10 ) )
    # nested tensor shape and indexing
    TNS: t2 = [[1,10],[11,100]]
    ASSERT( EQ( t2[1,1], 1 ) )
    ASSERT( EQ( t2[1,10], 10 ) )
    DEL(t1)
    DEL(t2)

    # --- Map literal and lookup ---
    MAP: mm = < "one" = 1, "two" = 10 >
    ASSERT( EQ( mm<"one">, 1 ) )
    ASSERT( EQ( mm<"two">, 10 ) )
    # assignment and deletion
    DEL(mm)

    # --- ASSIGN operator ---
    # Typed first assignment returns the assigned value
    ASSERT( EQ( ASSIGN(INT: ax, 1), 1 ) )
    ASSERT( EQ( ax, 1 ) )
    # Untyped assignment allowed once type exists
    ASSERT( EQ( ASSIGN(ax, 10), 10 ) )
    ASSERT( EQ( ax, 10 ) )
    DEL(ax)

    # Indexed ASSIGN on tensor
    TNS: at = [0, 0]
    ASSERT( EQ( ASSIGN(at[1], 1), 1 ) )
    ASSERT( EQ( at[1], 1 ) )
    DEL(at)

    # Indexed ASSIGN on map
    MAP: am = < "k" = 0 >
    ASSERT( EQ( ASSIGN(am<"k">, 1), 1 ) )
    ASSERT( EQ( am<"k">, 1 ) )
    DEL(am)

    # --- Pointer literal @ and simple aliasing ---
    # Pointer literals exist as expressions; avoid declaring unknown PTR type.
    INT: base = 1010
    STR: _ptr_sentinel = "@"  # placeholder to ensure @ token processed by lexer
    DEL(_ptr_sentinel)
    DEL(base)

    # --- Control flow: IF/ELSEIF/ELSE ---
    INT: cond = 1
    IF( EQ(cond, 1) ){
        ASSERT(1)
    } ELSEIF( EQ(cond, 0) ){
        ASSERT(0)
    } ELSE {
        ASSERT(0)
    }
    DEL(cond)

    # --- Loops: WHILE with CONTINUE and BREAK ---
    INT: cnt = 0
    INT: sum = 0
    WHILE( LT(cnt, 1011) ){   # 0..6
        cnt = ADD(cnt, 1)
        IF( EQ(cnt, 10) ){ CONTINUE() }   # skip when cnt == 2
        IF( EQ(cnt, 111) ){ BREAK(1) }     # break when cnt == 7
        sum = ADD(sum, cnt)
    }
    # simple sanity check: sum is non-negative
    ASSERT( GTE(sum, 0) )
    DEL(cnt)
    DEL(sum)

    # --- For (emulated) and PARFOR placeholder ---
    INT: idx = 1
    INT: acc = 0
    WHILE( LTE(idx, 11) ){  # 1..3
        acc = ADD(acc, idx)
        idx = ADD(idx, 1)
    }
    ASSERT( EQ(acc, 110) )
    DEL(idx)
    DEL(acc)

    # --- Functions (DECL + CALL), RETURN, and LAMBDA ---
    FUNC ID(INT: x):INT{ RETURN(x) }
    ASSERT( EQ( ID(101), 101 ) )

    FUNC FACT3():INT{
        INT: n = 11   # 3
        INT: r = 1
        WHILE( GT(n, 0) ){
            r = MUL(r, n)
            n = SUB(n, 1)
        }
        RETURN(r)
    }
    # 3! = 6 -> binary 110
    ASSERT( EQ( FACT3(), 110 ) )

    # --- Try/Catch behavior ---
    TRY{
        # Intentionally provoke a runtime fault (division by zero)
        INT: bad = DIV(1010, 0)
        ASSERT(0)  # should not reach here
    } CATCH(e){
        ASSERT(1)
    }

    # --- Error cases: ensure parse/runtime errors raise and are caught ---
    # (We avoid triggering parser errors here; runtime error above suffices.)

    # --- Misc: POP, DEL, PRINT side-effects ---
    FUNC TEST_POP():INT{
        INT: tmp = 101
        POP(tmp)
    }
    ASSERT( EQ( TEST_POP(), 101 ) )

    # --- Additional builtin coverage (previously untested) ---

    # Numeric helpers: ABS/GCD/LCM/ROOT/LOG/CLOG/CDIV
    ASSERT( EQ( ABS(-101), 101 ) )
    ASSERT( EQ( GCD(110, 1001), 11 ) )      # gcd(6,9)=3
    ASSERT( EQ( LCM(110, 1001), 10010 ) )   # lcm(6,9)=18
    ASSERT( EQ( ROOT(1000, 11), 10 ) )      # cube_root(8)=2
    ASSERT( EQ( ROOT(-1000, 11), -10 ) )
    ASSERT( EQ( LOG(1000), 11 ) )           # log2(8)=3
    ASSERT( EQ( CLOG(1001), 100 ) )         # ceil(log2(9))=4
    ASSERT( EQ( CDIV(101, 10), 11 ) )       # ceil(5/2)=3

    # SLICE on INT and STR
    ASSERT( EQ( SLICE(110110, 100, 10), 101 ) )        # 54[bits 4..2] -> 5
    ASSERT( EQ( SLICE("abcdef", 10, 1), "de" ) )

    # BOOL, ANY, ALL, XOR
    ASSERT( EQ( BOOL(0), 0 ) )
    ASSERT( EQ( BOOL(1), 1 ) )
    ASSERT( EQ( BOOL(""), 0 ) )
    ASSERT( EQ( BOOL([0, 0, 0]), 0 ) )
    ASSERT( EQ( BOOL([0, 1, 0]), 1 ) )
    ASSERT( EQ( ANY(0, 0, 1), 1 ) )
    ASSERT( EQ( ALL(1, 1, 1), 1 ) )
    ASSERT( EQ( ALL(1, 0), 0 ) )
    ASSERT( EQ( XOR(1, 0), 1 ) )
    ASSERT( EQ( XOR(1, 1), 0 ) )

    # SUM/PROD/MAX/MIN/LEN/SLEN/ILEN
    ASSERT( EQ( SUM(1, 10, 11), 110 ) )     # 1+2+3=6
    ASSERT( EQ( PROD(10, 11), 110 ) )       # 2*3=6
    ASSERT( EQ( MAX(1, 10, 11), 11 ) )
    ASSERT( EQ( MIN(1, 10, 11), 1 ) )
    ASSERT( EQ( LEN(1, "a", 10), 11 ) )    # number of args
    ASSERT( EQ( SLEN("abc"), 11 ) )
    ASSERT( EQ( ILEN(0), 1 ) )
    ASSERT( EQ( ILEN(10), 10 ) )            # bit_length(2)=2
    ASSERT( EQ( ILEN(-10), 10 ) )

    # Type conversions and string helpers
    ASSERT( EQ( INT("101"), 101 ) )
    ASSERT( EQ( INT(""), 0 ) )
    ASSERT( EQ( INT("foo"), 1 ) )
    ASSERT( EQ( FLT("0.1"), 0.1 ) )
    ASSERT( EQ( FLT("101"), 101.0 ) )
    ASSERT( EQ( STR(101), "101" ) )
    ASSERT( EQ( UPPER("Abc"), "ABC" ) )
    ASSERT( EQ( LOWER("AbC"), "abc" ) )
    ASSERT( EQ( STRIP("a--b--c", "--"), "abc" ) )

    TNS: parts = SPLIT("a,b,c", ",")
    ASSERT( EQ( TLEN(parts, 1), 11 ) )
    ASSERT( EQ( parts[1], "a" ) )
    ASSERT( EQ( parts[10], "b" ) )
    ASSERT( EQ( parts[11], "c" ) )
    DEL(parts)

    # New: TNS from a STR should produce a 1-D tensor of single-character STRs
    TNS: chars = TNS("foo")
    ASSERT( EQ( TLEN(chars, 1), 11 ) )
    ASSERT( EQ( chars[1], "f" ) )
    ASSERT( EQ( chars[10], "o" ) )
    ASSERT( EQ( chars[11], "o" ) )
    ASSERT( EQ( TNS("foo"), ["f","o","o"] ) )
    DEL(chars)

    # Maps: KEYS/VALUES/KEYIN/VALUEIN/INV and indexed DEL
    MAP: mm2 = < "one" = 1, "two" = 10 >
    TNS: ks = KEYS(mm2)
    TNS: vs = VALUES(mm2)
    ASSERT( EQ( TLEN(ks, 1), 10 ) )
    ASSERT( EQ( ks[1], "one" ) )
    ASSERT( EQ( ks[10], "two" ) )
    ASSERT( EQ( vs[1], 1 ) )
    ASSERT( EQ( vs[10], 10 ) )
    ASSERT( EQ( KEYIN("one", mm2), 1 ) )
    ASSERT( EQ( KEYIN("zzz", mm2), 0 ) )
    ASSERT( EQ( VALUEIN(10, mm2), 1 ) )
    ASSERT( EQ( VALUEIN(11, mm2), 0 ) )
    MAP: inv2 = INV(mm2)
    ASSERT( EQ( inv2<1>, "one" ) )
    ASSERT( EQ( inv2<10>, "two" ) )
    DEL(inv2<1>)
    ASSERT( EQ( KEYIN(1, inv2), 0 ) )
    # MATCH operator tests
    MAP: tmpl1 = < "one" = 1 >
    MAP: tmpl2 = < "one" = "x" >
    ASSERT( EQ( MATCH(mm2, tmpl1), 1 ) )
    ASSERT( EQ( MATCH(mm2, tmpl2), 1 ) )
    ASSERT( EQ( MATCH(mm2, tmpl1, 1), 1 ) )
    ASSERT( EQ( MATCH(mm2, tmpl2, 1), 0 ) )
    MAP: tmpl3 = < "one" = 1, "two" = 10 >
    ASSERT( EQ( MATCH(mm2, tmpl3), 1 ) )
    MAP: tmpl4 = < "three" = 1 >
    ASSERT( EQ( MATCH(mm2, tmpl4), 0 ) )

    # MATCH recurse flag: when true, apply same template rules to nested MAPs.
    MAP: mmr_ok = < "one" = 1, "child" = < "one" = 1 > >
    ASSERT( EQ( MATCH(mmr_ok, tmpl1, 0, 0), 1 ) )
    ASSERT( EQ( MATCH(mmr_ok, tmpl1, 0, 1), 1 ) )
    MAP: mmr_bad = < "one" = 1, "child" = < "two" = 10 > >
    ASSERT( EQ( MATCH(mmr_bad, tmpl1, 0, 0), 1 ) )
    ASSERT( EQ( MATCH(mmr_bad, tmpl1, 0, 1), 0 ) )
    # recurse + typing: nested MAP must also satisfy typing constraint.
    MAP: mmr_tbad = < "one" = 1, "child" = < "one" = "x" > >
    ASSERT( EQ( MATCH(mmr_tbad, tmpl1, 1, 0), 1 ) )
    ASSERT( EQ( MATCH(mmr_tbad, tmpl1, 1, 1), 0 ) )

    # MATCH shape flag: when true, require matching TNS shapes.
    TNS: s1 = [1, 10, 11]
    TNS: s1b = [0, 0, 0]
    TNS: s2 = [[1,10],[11,100]]
    MAP: mshape_ok = < "t" = s1 >
    MAP: tshape_ok = < "t" = s1b >
    ASSERT( EQ( MATCH(mshape_ok, tshape_ok, 1, 0, 1), 1 ) )
    MAP: tshape_bad = < "t" = s2 >
    ASSERT( EQ( MATCH(mshape_ok, tshape_bad, 1, 0, 1), 0 ) )
    # If shape is enabled and either side is a TNS, both must be TNS.
    MAP: mshape_non = < "t" = 1 >
    ASSERT( EQ( MATCH(mshape_non, tshape_ok, 0, 0, 0), 1 ) )
    ASSERT( EQ( MATCH(mshape_non, tshape_ok, 0, 0, 1), 0 ) )

    DEL(mmr_ok)
    DEL(mmr_bad)
    DEL(mmr_tbad)
    DEL(s1)
    DEL(s1b)
    DEL(s2)
    DEL(mshape_ok)
    DEL(tshape_ok)
    DEL(tshape_bad)
    DEL(mshape_non)
    DEL(tmpl1)
    DEL(tmpl2)
    DEL(tmpl3)
    DEL(tmpl4)
    DEL(ks)
    DEL(vs)
    DEL(inv2)
    DEL(mm2)

    # Environment/introspection: MAIN/OS/ARGV/EXIST/IS*/TYPE/SIGNATURE
    ASSERT( EQ( MAIN(), 1 ) )
    ASSERT( EQ( BOOL(OS()), 1 ) )
    TNS: av = ARGV()
    ASSERT( GTE( TLEN(av, 1), 1 ) )
    DEL(av)

    INT: exv = 1
    ASSERT( EQ( EXIST(exv), 1 ) )
    ASSERT( EQ( ISINT(exv), 1 ) )
    ASSERT( EQ( ISSTR(exv), 0 ) )
    ASSERT( EQ( ISFLT(exv), 0 ) )
    ASSERT( EQ( ISTNS(exv), 0 ) )
    ASSERT( EQ( TYPE(exv), "INT" ) )
    ASSERT( EQ( SIGNATURE(exv), "INT: exv" ) )
    DEL(exv)
    ASSERT( EQ( EXIST(exv), 0 ) )

    FUNC SIGF(INT: x):INT{ RETURN(x) }
    ASSERT( EQ( SIGNATURE(SIGF), "FUNC SIGF(INT: x):INT" ) )

    # FREEZE/THAW/PERMAFREEZE/FROZEN/PERMAFROZEN
    INT: fz = 1
    FREEZE(fz)
    ASSERT( EQ( FROZEN(fz), 1 ) )
    THAW(fz)
    ASSERT( EQ( FROZEN(fz), 0 ) )
    PERMAFREEZE(fz)
    ASSERT( EQ( PERMAFROZEN(fz), 1 ) )
    ASSERT( EQ( FROZEN(fz), -1 ) )

    # COPY vs DEEPCOPY (maps with nested maps)
    MAP: inner = < "k" = 1 >
    MAP: outer = < "inner" = inner >
    MAP: outer_sh = COPY(outer)
    MAP: outer_dp = DEEPCOPY(outer)
    inner<"k"> = 10
    ASSERT( EQ( outer<"inner"><"k">, 10 ) )
    ASSERT( EQ( outer_sh<"inner"><"k">, 10 ) )
    ASSERT( EQ( outer_dp<"inner"><"k">, 1 ) )
    DEL(inner)
    DEL(outer)
    DEL(outer_sh)
    DEL(outer_dp)

    # SER/UNSER round-trip (INT/TNS/MAP)
    STR: ser_i = SER(101)
    ASSERT( EQ( UNSER(ser_i), 101 ) )
    DEL(ser_i)

    TNS: ser_t = [1, 10, 11]
    STR: ser_ts = SER(ser_t)
    TNS: ser_t2 = UNSER(ser_ts)
    ASSERT( EQ( ser_t2[1], 1 ) )
    ASSERT( EQ( ser_t2[10], 10 ) )
    ASSERT( EQ( ser_t2[11], 11 ) )
    DEL(ser_t)
    DEL(ser_ts)
    DEL(ser_t2)

    MAP: ser_m = < "a" = 1, "b" = 10 >
    STR: ser_ms = SER(ser_m)
    MAP: ser_m2 = UNSER(ser_ms)
    ASSERT( EQ( ser_m2<"a">, 1 ) )
    ASSERT( EQ( ser_m2<"b">, 10 ) )
    DEL(ser_m)
    DEL(ser_ms)
    DEL(ser_m2)

    # SER/UNSER round-trip (FUNC/THR)
    FUNC: ser_fn = LAMBDA(INT: x):INT{ RETURN( ADD(x, 1) ) }
    STR: ser_fn_s = SER(ser_fn)
    FUNC: ser_fn2 = UNSER(ser_fn_s)
    ASSERT( EQ( ser_fn2(1), 10 ) )
    DEL(ser_fn)
    DEL(ser_fn_s)
    DEL(ser_fn2)

    THR(tser){ }
    STR: ser_thr = SER(tser)
    THR: ser_thr2 = UNSER(ser_thr)
    ASSERT( EQ( TYPE(ser_thr2), "THR" ) )
    AWAIT(ser_thr2)
    DEL(tser)
    DEL(ser_thr)
    DEL(ser_thr2)

    # ROUND (binary float semantics)
    ASSERT( EQ( ROUND(0.11, "floor", 1), 0.1 ) )
    ASSERT( EQ( ROUND(0.11, "ceiling", 1), 1.0 ) )

    # File I/O: WRITEFILE/READFILE/EXISTFILE
    ASSERT( EQ( WRITEFILE("hello", "_pre_tmp.txt"), 1 ) )
    ASSERT( EQ( EXISTFILE("_pre_tmp.txt"), 1 ) )
    ASSERT( EQ( READFILE("_pre_tmp.txt"), "hello" ) )

    ASSERT( EQ( WRITEFILE("01000001", "_pre_tmp.bin", "binary"), 1 ) )
    ASSERT( EQ( READFILE("_pre_tmp.bin", "binary"), "01000001" ) )

    ASSERT( EQ( WRITEFILE("41", "_pre_tmp.hex", "hex"), 1 ) )
    ASSERT( EQ( READFILE("_pre_tmp.hex", "hex"), "41" ) )

    # Cleanup temp files
    DELETEFILE("_pre_tmp.txt")
    DELETEFILE("_pre_tmp.bin")
    DELETEFILE("_pre_tmp.hex")
    ASSERT( EQ( EXISTFILE("_pre_tmp.txt"), 0 ) )
    ASSERT( EQ( EXISTFILE("_pre_tmp.bin"), 0 ) )
    ASSERT( EQ( EXISTFILE("_pre_tmp.hex"), 0 ) )

    TRY{
        DELETEFILE("_pre_nonexistent_file.txt")
        ASSERT(0)  # should not reach here
    } CATCH {}

    # CL + IMPORT/IMPORT_PATH/EXPORT (keep platform-safe)
    STR: osfam = OS()
    IF( EQ(osfam, "win") ){
        ASSERT( EQ( CL("cmd /c exit 0"), 0 ) )
        ASSERT( EQ( CL("cmd /c cd > _pre_cwd.txt"), 0 ) )
    } ELSE {
        ASSERT( EQ( CL("true"), 0 ) )
        ASSERT( EQ( CL("pwd > _pre_cwd.txt"), 0 ) )
    }

    STR: mod_src = "INT: v = 1\nFUNC G():INT{ RETURN(10) }\n"
    ASSERT( EQ( WRITEFILE(mod_src, "tmpmod.pre"), 1 ) )

    STR: cwd = READFILE("_pre_cwd.txt")
    DELETEFILE("_pre_cwd.txt")
    cwd = STRIP(cwd, "\r")
    cwd = STRIP(cwd, "\n")
    STR: mod_path = ""
    IF( EQ(osfam, "win") ){
        mod_path = JOIN(cwd, "\\", "tmpmod.pre")
    } ELSE {
        mod_path = JOIN(cwd, "/", "tmpmod.pre")
    }

    ASSERT( EQ( IMPORT_PATH(mod_path), 0 ) )
    DELETEFILE("tmpmod.pre")
    ASSERT( EQ( tmpmod.v, 1 ) )
    ASSERT( EQ( tmpmod.G(), 10 ) )

    IMPORT(tmpmod, m)
    ASSERT( EQ( m.v, 1 ) )
    ASSERT( EQ( m.G(), 10 ) )

    INT: local_export = 11
    # Ensure a name `tmpmod` exists as an identifier so EXPORT's
    # argument evaluation doesn't raise 'Undefined identifier'. Create
    # a temporary dummy value and remove it after exporting.
    INT: tmpmod = 0
    EXPORT(local_export, tmpmod)
    ASSERT( EQ( tmpmod.local_export, local_export ) )
    DEL(local_export)
    DEL(tmpmod)

    # RUN executes source in current environment
    ASSERT( EQ( RUN("INT: runv = 10\n"), 0 ) )
    ASSERT( EQ( runv, 10 ) )
    DEL(runv)

    # SHUSH/UNSHUSH smoke test (effects are on output sink)
    ASSERT( EQ( SHUSH(), 0 ) )
    PRINT("(shushed)")
    ASSERT( EQ( UNSHUSH(), 0 ) )

    # Tensors: SHAPE/FILL/TNS/TINT/TFLT/TSTR + arithmetic helpers
    TNS: base_t = [1, 10, 11]
    TNS: shp = SHAPE(base_t)
    ASSERT( EQ( TLEN(shp, 1), 1 ) )
    ASSERT( EQ( shp[1], 11 ) )
    TNS: filled = FILL(base_t, 0)
    ASSERT( EQ( filled[1], 0 ) )
    ASSERT( EQ( filled[10], 0 ) )
    ASSERT( EQ( filled[11], 0 ) )
    DEL(shp)
    DEL(filled)

    TNS: made = TNS([10, 11], 1)   # shape [2,3]
    ASSERT( EQ( TLEN(made, 1), 10 ) )
    ASSERT( EQ( TLEN(made, 10), 11 ) )
    ASSERT( EQ( made[1,1], 1 ) )
    DEL(made)

    TNS: strnums = ["101", "0", ""]
    TNS: as_ints = TINT(strnums)
    ASSERT( EQ( as_ints[1], 101 ) )
    ASSERT( EQ( as_ints[10], 0 ) )
    ASSERT( EQ( as_ints[11], 0 ) )
    TNS: as_flts = TFLT(["0.1", "1", "10"])  # 0.5,1.0,2.0
    ASSERT( EQ( as_flts[1], 0.1 ) )
    ASSERT( EQ( as_flts[10], 1.0 ) )
    ASSERT( EQ( as_flts[11], 10.0 ) )
    TNS: as_strs = TSTR([1, 10, 11])
    ASSERT( EQ( as_strs[1], "1" ) )
    ASSERT( EQ( as_strs[10], "10" ) )
    ASSERT( EQ( as_strs[11], "11" ) )
    DEL(strnums)
    DEL(as_ints)
    DEL(as_flts)
    DEL(as_strs)

    # Matrix/tensor elementwise ops
    TNS: a1 = [1, 10]
    TNS: a2 = [11, 100]
    TNS: madd = MADD(a1, a2)
    ASSERT( EQ( madd[1], 100 ) )
    ASSERT( EQ( madd[10], 110 ) )
    TNS: msum = MSUM(a1, a2, [1, 1])
    ASSERT( EQ( msum[1], 101 ) )
    ASSERT( EQ( msum[10], 111 ) )
    TNS: tadd = TADD(a1, 1)
    ASSERT( EQ( tadd[1], 10 ) )
    ASSERT( EQ( tadd[10], 11 ) )
    TNS: tpow = TPOW([10, 11], 10)  # [2,3]^2
    ASSERT( EQ( tpow[1], 100 ) )
    ASSERT( EQ( tpow[10], 1001 ) )
    DEL(a1)
    DEL(a2)
    DEL(madd)
    DEL(msum)
    DEL(tadd)
    DEL(tpow)

    # FLIP/TFLIP/SCAT/CONV
    ASSERT( EQ( FLIP(1010), 101 ) )
    ASSERT( EQ( FLIP("abc"), "cba" ) )

    TNS: tf = TFLIP([[1,10],[11,100]], 1)
    ASSERT( EQ( tf[1,1], 11 ) )
    ASSERT( EQ( tf[10,1], 1 ) )
    DEL(tf)

    TNS: dst = [0,0,0,0]
    TNS: src = [1,1]
    TNS: ind = [[10,11]]
    TNS: scat = SCAT(src, dst, ind)
    ASSERT( EQ( scat[1], 0 ) )
    ASSERT( EQ( scat[10], 1 ) )
    ASSERT( EQ( scat[11], 1 ) )
    ASSERT( EQ( scat[100], 0 ) )
    DEL(dst)
    DEL(src)
    DEL(ind)
    DEL(scat)

    TNS: conv = CONV([1,10,11], [1,1,1])
    ASSERT( EQ( conv[1], 100 ) )
    ASSERT( EQ( conv[10], 110 ) )
    ASSERT( EQ( conv[11], 1000 ) )
    DEL(conv)

    # PARALLEL (FUNC values)
    FUNC P1():INT{ RETURN(1) }
    FUNC P2():INT{ RETURN(10) }
    ASSERT( EQ( PARALLEL([P1, P2]), 0 ) )
    ASSERT( EQ( PARALLEL(P1, P2), 0 ) )

    # BYTES
    TNS: bbig = BYTES(100000000)  # 256 -> [1,0]
    ASSERT( EQ( TLEN(bbig, 1), 10 ) )
    ASSERT( EQ( bbig[1], 1 ) )
    ASSERT( EQ( bbig[10], 0 ) )
    TNS: blit = BYTES(100000000, "little")
    ASSERT( EQ( TLEN(blit, 1), 10 ) )
    ASSERT( EQ( blit[1], 0 ) )
    ASSERT( EQ( blit[10], 1 ) )
    DEL(bbig)
    DEL(blit)

    # Operators that are inherently interactive/terminating are referenced only in dead
    # code.
    IF(0){
        INPUT("Press Enter (manual test)")
        EXIT(0)
    }
    ASSERT( EQ( EXIST(tmp), 0 ) )
    PRINT("Built-in tests passed.\n")
}

FUNC STDLIB_TESTS():INT{
    PRINT("Running library tests...")

    # PRNG reproducibility (LCG)
    prng.SEED(1010)   # seed = 10
    INT: a = prng.NEXT()
    prng.SEED(1010)
    INT: b = prng.NEXT()
    ASSERT( EQ(a, b) )
    DEL(a)
    DEL(b)

    PRINT("PRNG tests passed.")

    # CSPRNG reproducibility (ChaCha-based)
    csprng.SEED(101)  # seed = 5
    INT: x = csprng.NEXT()
    csprng.SEED(101)
    INT: y = csprng.NEXT()
    ASSERT( EQ(x, y) )
    DEL(x)
    DEL(y)
    INT: ran = csprng.RANGE(10000)
    ASSERT( AND( GTE(ran, 0), LTE(ran, 10000) ) )
    DEL(ran)
    INT: ran2 = csprng.RANGE_MIN_MAX(1000, 10000)
    ASSERT( AND( GTE(ran2, 1000), LTE(ran2, 10000) ) )
    PRINT("CSPRNG tests passed.")

    # Prime library tests
    # Basic primality checks
    ASSERT( EQ( prime.IS_PRIME(10), 1 ) )    # 2 is prime
    ASSERT( EQ( prime.IS_PRIME(11), 1 ) )    # 3 is prime
    ASSERT( EQ( prime.IS_PRIME(100), 0 ) )   # 4 is not prime
    ASSERT( EQ( prime.IS_PRIME(101), 1 ) )   # 5 is prime

    # NEXT_PRIME / PREV_PRIME
    ASSERT( EQ( prime.NEXT_PRIME(100), 101 ) )   # next prime after 4 is 5
    ASSERT( EQ( prime.PREV_PRIME(101), 11 ) )    # previous prime before 5 is 3

    # Mersenne prime check (p=3 -> 2^3-1 = 7, prime)
    ASSERT( EQ( prime.IS_MERSENNE_PRIME(11), 1 ) )

    # FACTOR: factor 10 (1010) -> [2 (10), 5 (101)]
    TNS: factors = prime.FACTOR(1010)
    ASSERT( EQ( TLEN(factors, 1), 10 ) )
    ASSERT( EQ( factors[1], 10 ) )
    ASSERT( EQ( factors[10], 101 ) )
    DEL(factors)

    PRINT("Prime library tests passed.")

    # Numbers library tests
    ASSERT( EQ(numbers.VALUE("10", 1010), 1010) )
    ASSERT( EQ(numbers.VALUE("A", 10000), 1010) )
    ASSERT( EQ(numbers.CONVERT("10", 1010, 10000), "A") )
    ASSERT( EQ(numbers.CONVERT("A", 10000, 1010), "10") )
    ASSERT( EQ(numbers.binary, 10) )
    ASSERT( EQ(numbers.octal, 1000) )
    ASSERT( EQ(numbers.decimal, 1010) )
    ASSERT( EQ(numbers.hexadecimal, 10000) )
    ASSERT( EQ(numbers.duotrigesimal, 100000) )
    ASSERT( EQ(numbers.base32, 100000) )
    ASSERT( EQ(numbers.base64, 1000000) )
    PRINT("Numbers library tests passed.")

    # Path library tests
    ASSERT( EQ(path.NORMALIZE_PATH("a\\b\\c"), "a/b/c") )
    ASSERT( EQ(path.WINPATH("a/b/c"), "a\\b\\c") )
    ASSERT( EQ(path.BASENAME("a/b/c.txt"), "c.txt") )
    ASSERT( EQ(path.EXTNAME("foo.bar"), "bar") )
    ASSERT( EQ(path.DELEXT("foo.bar"), "foo") )
    ASSERT( EQ(path.EXTNAME("foo"), "") )
    ASSERT( EQ(path.DELEXT("foo"), "foo") )
    IF(EQ(OS(),"win")){
        ASSERT( EQ(path.TEMPFILE("myfile.txt"), "C:/Windows/Temp/myfile.txt") )
    } ELSEIF (EQ(OS(),"linux")){
        ASSERT( EQ(path.TEMPFILE("myfile.txt"), "/tmp/myfile.txt") )
    }

    PRINT("Path library tests passed.")

    # Waveform library tests
    INT: freq = 1100100      # 100
    INT: ms = 1010           # 10
    INT: amp = 1010          # 10
    INT: sr = 1111101000     # 1000
    INT: duty0 = 0
    INT: duty50 = 110010     # 50

    # Generators
    TNS: sq = waveforms.SQUARE(freq, ms, amp, sr)
    ASSERT(EQ(TLEN(sq, 1), ms))
    ASSERT(EQ(sq[1], amp))
    ASSERT(EQ(sq[110], NEG(amp)))

    TNS: saw = waveforms.SAWTOOTH(freq, ms, amp, sr)
    ASSERT(EQ(TLEN(saw, 1), ms))
    ASSERT(EQ(saw[1], NEG(amp)))
    ASSERT(EQ(saw[10], NEG(110)))   # -6
    ASSERT(EQ(saw[1010], 11010))    # 26
    DEL(saw)

    TNS: tri = waveforms.TRIANGLE(freq, ms, amp, sr)
    ASSERT(EQ(TLEN(tri, 1), ms))
    ASSERT(EQ(tri[1], NEG(amp)))
    ASSERT(EQ(tri[110], amp))
    ASSERT(EQ(tri[1010], NEG(110)))
    DEL(tri)

    TNS: pulse0 = waveforms.PULSE(freq, ms, amp, sr, duty0)
    DEL(duty0)
    ASSERT(EQ(TLEN(pulse0, 1), ms))
    ASSERT(EQ(pulse0[1], NEG(amp)))
    DEL(pulse0)

    TNS: pulse50 = waveforms.PULSE(freq, ms, amp, sr, duty50)
    DEL(duty50)
    ASSERT(EQ(TLEN(pulse50, 1), ms))
    ASSERT(EQ(pulse50[1], amp))
    ASSERT(EQ(pulse50[110], NEG(amp)))
    DEL(amp)
    DEL(pulse50)

    TNS: sine0 = waveforms.SINE(freq, ms, 0, sr)
    DEL(sr)
    ASSERT(EQ(TLEN(sine0, 1), ms))
    ASSERT(EQ(sine0[1], 0))
    ASSERT(EQ(sine0[1010], 0))
    DEL(freq)
    DEL(sine0)

    # Filters
    TNS: env = waveforms.ENVELOPE_ADSR(SHAPE(sq), 10, 10, 10, 10)
    DEL(sq)
    ASSERT(EQ(TLEN(env, 1), ms))
    DEL(ms)
    ASSERT(EQ(env[1], 10))
    ASSERT(EQ(env[101], 10))
    ASSERT(EQ(env[1010], 1))
    DEL(env)

    TNS: filt_in = [0, 1, 10]
    TNS: low = waveforms.LOWPASS(filt_in, 1100100, 1100100)
    ASSERT(EQ(TLEN(low, 1), 11))
    ASSERT(EQ(low[1], 0))
    ASSERT(EQ(low[10], 1))
    ASSERT(EQ(low[11], 10))
    DEL(low)

    TNS: high = waveforms.HIGHPASS(filt_in, 1100100, 1100100)
    DEL(filt_in)
    ASSERT(EQ(TLEN(high, 1), 11))
    ASSERT(EQ(high[1], 0))
    ASSERT(EQ(high[11], 0))
    DEL(high)

    PRINT("Waveform library tests passed.")

    # Stats library tests
    TNS: svals1 = [1,10,11]  # values: 1,2,3 (binary literals)
    ASSERT( EQ( stats.MEAN(svals1), 10.0 ) )     # mean = 2.0
    ASSERT( EQ( stats.MEDIAN(svals1), 10.0 ) )   # median = 2.0

    TNS: svals2 = [1,10,11,100]  # values: 1,2,3,4
    ASSERT( EQ( stats.MEAN(svals2), 10.1 ) )     # mean = 2.5 (10.1)
    ASSERT( EQ( stats.MEDIAN(svals2), 10.1 ) )   # median = 2.5 (10.1)
    DEL(svals2)

    # Quantile: q=0 should return minimum
    ASSERT( EQ( stats.QUANTILE(svals1, 0, 10), 1.0 ) )

    # Variance / stdev (population) for [1,2,3] is small -> integer division yields 0
    ASSERT( EQ( stats.VARIANCE(svals1, 0), 0.0 ) )
    ASSERT( EQ( stats.STDEV(svals1, 0), 0.0 ) )

    TNS: mode1 = stats.MODE(svals1)
    # All values appear once -> all are modes (length 3 -> binary '11')
    ASSERT( EQ( TLEN(mode1, 1), 11 ) )
    DEL(mode1)

    # Histogram with 2 bins (bins=10 binary) -> first bin count 2, second bin 1
    TNS: hist1 = stats.HISTOGRAM(svals1, 10)
    ASSERT( EQ( TLEN(hist1, 1), 10 ) )
    ASSERT( EQ( hist1[1], 10 ) )
    ASSERT( EQ( hist1[10], 1 ) )
    DEL(hist1)

    TNS: desc1 = stats.DESCRIBE(svals1)
    DEL(svals1)
    ASSERT( EQ( TLEN(desc1, 1), 101 ) )   # length 5 -> binary 101
    ASSERT( EQ( desc1[1], 11 ) )          # count = 3
    ASSERT( EQ( desc1[10], 10 ) )          # mean = 2
    ASSERT( EQ( desc1[11], 0 ) )           # stdev (as implemented)
    ASSERT( EQ( desc1[100], 1 ) )           # min
    ASSERT( EQ( desc1[101], 11 ) )          # max
    DEL(desc1)
    PRINT("Stats library tests passed.")

    # image library
    STR: bmp_path = JOIN(path.interpreter_dir,"/docs/icon.bmp")
    STR: png_path = JOIN(path.interpreter_dir,"/docs/icon.png")
    STR: jpeg_path = JOIN(path.interpreter_dir,"/docs/icon.jpg")
    TNS: bmp = image.LOAD_BMP(bmp_path)
    DEL(bmp_path)
    TNS: png = image.LOAD_PNG(png_path)
    DEL(png_path)
    # Convenience loader (auto-detect)
    TNS: auto_png = image.LOAD(JOIN(path.interpreter_dir, "/docs/icon.png"))
    ASSERT(EQ(auto_png, png))
    DEL(auto_png)
    image.LOAD_JPEG(jpeg_path)
    DEL(jpeg_path)
    ASSERT(EQ(bmp, png))
    ASSERT(EQ(image.FLIP_V(image.FLIP_V(bmp)), bmp))
    ASSERT(EQ(image.FLIP_H(image.FLIP_H(bmp)), bmp))
    ASSERT(EQ(image.WIDTH(bmp), 10101010))
    ASSERT(EQ(image.HEIGHT(bmp), 10101010))
    ASSERT(EQ(image.CHANNELS(bmp), 100))

    # Pixel / channel access consistency
    TNS: p = image.PIXEL(bmp, 1, 1)
    ASSERT(EQ(p[1], image.PIXEL_R(bmp, 1, 1)))
    ASSERT(EQ(p[10], image.PIXEL_G(bmp, 1, 1)))
    ASSERT(EQ(p[11], image.PIXEL_B(bmp, 1, 1)))
    ASSERT(EQ(p[100], image.PIXEL_A(bmp, 1, 1)))
    DEL(p)

    # Channel extractor helpers (R/G/B/A)
    ASSERT(EQ(image.R(bmp)[1,1], image.PIXEL_R(bmp, 1, 1)))
    ASSERT(EQ(image.G(bmp)[1,1], image.PIXEL_G(bmp, 1, 1)))
    ASSERT(EQ(image.B(bmp)[1,1], image.PIXEL_B(bmp, 1, 1)))
    ASSERT(EQ(image.A(bmp)[1,1], image.PIXEL_A(bmp, 1, 1)))

    # Double-invert returns original
    ASSERT(EQ(image.INVERT(image.INVERT(bmp)), bmp))

    # REPLACE_COLOR: draw a filled rect and replace red with green
    TNS: canvas_rc = TNS([1011,1011,100], 0)
    TNS: redcol = [11111111, 0, 0, 11111111]
    TNS: greencol = [0, 11111111, 0, 11111111]
    TNS: filled_rc = image.FILL_RECT(canvas_rc, 1, 1, 1011, 1011, redcol)
    DEL(canvas_rc)
    TNS: replaced = image.REPLACE_COLOR(filled_rc, redcol, greencol)
    DEL(redcol)
    DEL(greencol)
    DEL(filled_rc)
    ASSERT(EQ(image.PIXEL_R(replaced, 1, 1), 0))
    ASSERT(EQ(image.PIXEL_G(replaced, 1, 1), 11111111))
    DEL(replaced)

    # Scale (identity) preserves dimensions
    TNS: scaled = image.SCALE(bmp, 1.0, 1.0)
    ASSERT(EQ(image.WIDTH(scaled), image.WIDTH(bmp)))
    ASSERT(EQ(image.HEIGHT(scaled), image.HEIGHT(bmp)))
    DEL(scaled)

    # Blit into an empty canvas and verify top-left pixel copied
    TNS: canvas = TNS(SHAPE(bmp), 0)
    TNS: canv2 = image.BLIT(bmp, canvas, 1, 1)
    DEL(canvas)
    ASSERT(EQ(canv2[1,1,1], bmp[1,1,1]))
    DEL(canv2)

    # Grayscale / Blur run and preserve height
    TNS: gray = image.GRAYSCALE(bmp)
    ASSERT(EQ(TLEN(gray, 1), TLEN(bmp, 1)))
    DEL(gray)
    TNS: blurred = image.BLUR(bmp, 1)
    ASSERT(EQ(TLEN(blurred, 1), TLEN(bmp, 1)))
    DEL(blurred)

    # Additional image operator coverage
    STR: out_bmp = JOIN(path.interpreter_dir, "/out_test.bmp")
    STR: out_png = JOIN(path.interpreter_dir, "/out_test.png")
    STR: out_jpeg = JOIN(path.interpreter_dir, "/out_test.jpg")

    # SHOW (only run on Windows to avoid opening viewers on other platforms)
    IF(EQ(OS(), "win")){
        INT: show_rc = image.SHOW(bmp)
        ASSERT(EQ(show_rc, 0))
        DEL(show_rc)
    }

    # SAVE/LOAD roundtrip (BMP/PNG/JPEG)
    ASSERT(EQ(image.SAVE_BMP(bmp, out_bmp), "OK"))
    TNS: bmp_rt = image.LOAD_BMP(out_bmp)
    IF(EQ(OS(),"win")){
        CL(JOIN('del "', REPLACE(out_bmp,'/','\\'), '"'))
    } ELSE {
        CL(JOIN('rm "', out_bmp, '"'))
    }
    DEL(out_bmp)
    ASSERT(EQ(bmp_rt, bmp))
    DEL(bmp_rt)

    ASSERT(EQ(image.SAVE_PNG(bmp, out_png, 1010), "OK"))
    TNS: png_rt = image.LOAD_PNG(out_png)
    IF(EQ(OS(),"win")){
        CL(JOIN('del "', REPLACE(out_png,'/','\\'), '"'))
    } ELSE {
        CL(JOIN('rm "', out_png, '"'))
    }
    DEL(out_png)
    ASSERT(EQ(png_rt, bmp))
    DEL(png_rt)
    # Use a high JPEG quality (95 -> binary 1011111). JPEG is lossy so
    # require dimensions match and per-channel values be close.
    ASSERT(EQ(image.SAVE_JPEG(bmp, out_jpeg, 1011111), "OK"))
    TNS: jpeg_rt2 = image.LOAD_JPEG(out_jpeg)
    IF(EQ(OS(),"win")){
        CL(JOIN('del "', REPLACE(out_jpeg,'/','\\'), '"'))
    } ELSE {
        CL(JOIN('rm "', out_jpeg, '"'))
    }
    DEL(out_jpeg)
    ASSERT(EQ(image.WIDTH(jpeg_rt2), image.WIDTH(bmp)))
    ASSERT(EQ(image.HEIGHT(jpeg_rt2), image.HEIGHT(bmp)))
    ASSERT(EQ(image.CHANNELS(jpeg_rt2), image.CHANNELS(bmp)))
    INT: dr = ABS(SUB(image.PIXEL_R(jpeg_rt2, 1, 1), image.PIXEL_R(bmp, 1, 1)))
    INT: dg = ABS(SUB(image.PIXEL_G(jpeg_rt2, 1, 1), image.PIXEL_G(bmp, 1, 1)))
    INT: db = ABS(SUB(image.PIXEL_B(jpeg_rt2, 1, 1), image.PIXEL_B(bmp, 1, 1)))
    DEL(jpeg_rt2)
    # allow small per-channel differences (<=3)
    ASSERT(LTE(dr, 11))
    DEL(dr)
    ASSERT(LTE(dg, 11))
    DEL(dg)
    ASSERT(LTE(db, 11))
    DEL(db)

    # CROP with zeros returns identical image (new signature: corners tensor)
    TNS: crop_same = image.CROP(bmp, [ ^
        [1, 1], ^
        [TLEN(bmp, 10), 1], ^
        [1, TLEN(bmp, 1)], ^
        [TLEN(bmp, 10), TLEN(bmp, 1)] ^
    ])
    ASSERT(EQ(crop_same, bmp))
    DEL(crop_same)

    # SCALE with factor 2 (binary 10) doubles dimensions
    TNS: scaled2 = image.SCALE(bmp, 10.0, 10.0)
    ASSERT(EQ(image.WIDTH(scaled2), MUL(image.WIDTH(bmp), 10)))
    ASSERT(EQ(image.HEIGHT(scaled2), MUL(image.HEIGHT(bmp), 10)))
    DEL(scaled2)

    # RESIZE: downscale and upscale preserve requested dimensions
    INT: orig_w = image.WIDTH(png)
    INT: orig_h = image.HEIGHT(png)
    INT: half_w = DIV(orig_w, 10)
    INT: half_h = DIV(orig_h, 10)
    TNS: resized_small = image.RESIZE(png, half_w, half_h, 1)
    ASSERT(EQ(image.WIDTH(resized_small), half_w))
    ASSERT(EQ(image.HEIGHT(resized_small), half_h))
    DEL(resized_small)

    INT: dbl_w = MUL(orig_w, 10)
    INT: dbl_h = MUL(orig_h, 10)
    TNS: resized_big = image.RESIZE(png, dbl_w, dbl_h, 1)
    DEL(png)
    ASSERT(EQ(image.WIDTH(resized_big), dbl_w))
    ASSERT(EQ(image.HEIGHT(resized_big), dbl_h))
    DEL(resized_big)

    DEL(orig_w)
    DEL(orig_h)
    DEL(half_w)
    DEL(half_h)
    DEL(dbl_w)
    DEL(dbl_h)

    # ROTATE by 0 degrees is identity
    TNS: rot0 = image.ROTATE(bmp, 0.0)
    ASSERT(EQ(rot0, bmp))
    DEL(rot0)

    # BLIT with mixalpha=0 should copy pixels exactly
    TNS: canvas2 = TNS(SHAPE(bmp), 0)
    TNS: blit_out = image.BLIT(bmp, canvas2, 1, 1, 0)
    DEL(canvas2)
    ASSERT(EQ(image.PIXEL(blit_out, 1, 1), image.PIXEL(bmp, 1, 1)))
    DEL(bmp)
    DEL(blit_out)

    # Shape drawing and primitive operators
    # small canvas: 11x11x4 (binary 1011 = 11, 100 = 4 channels)
    TNS: small = TNS([1011,1011,100], 0)
    TNS: red = [11111111, 0, 0, 11111111]

    # RECT / RECTANGLE / SQUARE / FILL_RECT
    TNS: rect_out = image.RECT(small, 10, 10, 101, 101, red, 1, 1)
    ASSERT(EQ(TLEN(rect_out, 1), TLEN(small, 1)))
    ASSERT(EQ(rect_out[10,10,1], red[1]))
    DEL(rect_out)

    TNS: rect2 = image.RECTANGLE(small, 10, 10, 101, 101, red, 1, 1)
    ASSERT(EQ(TLEN(rect2, 1), TLEN(small, 1)))
    DEL(rect2)

    TNS: sq = image.SQUARE(small, 10, 10, 101, red, 1, 1)
    ASSERT(EQ(TLEN(sq, 1), TLEN(small, 1)))
    DEL(sq)

    TNS: filled = image.FILL_RECT(small, 10, 10, 101, 101, red)
    ASSERT(EQ(TLEN(filled, 1), TLEN(small, 1)))
    DEL(filled)

    # ELLIPSE / FILL_ELLIPSE / CIRCLE
    TNS: ell = image.ELLIPSE(small, [100,100], 11, 101, red, 1, 1)
    ASSERT(EQ(TLEN(ell, 1), TLEN(small, 1)))
    DEL(ell)

    TNS: fill_ell = image.FILL_ELLIPSE(small, [100,100], 11, 101, red)
    ASSERT(EQ(TLEN(fill_ell, 1), TLEN(small, 1)))
    DEL(fill_ell)

    TNS: circ = image.CIRCLE(small, [100,100], 11, red, 1, 1)
    ASSERT(EQ(TLEN(circ, 1), TLEN(small, 1)))
    DEL(circ)

    # POLYGON
    TNS: pts = [ ^
        [10, 10], ^
        [110, 10], ^
        [100, 110], ^
        [10, 10] ^
    ]
    TNS: poly = image.POLYGON(small, pts, red, 1, 1)
    ASSERT(EQ(TLEN(poly, 1), TLEN(small, 1)))
    DEL(poly)

    # Cleanup small canvas
    DEL(small)
    DEL(red)

    # New tests: threshold operators, edge detector, and cellshade
    TNS: th_canvas = TNS([1011,1011,100], 0)
    TNS: red2 = [11111111, 0, 0, 11111111]
    TNS: filled_th = image.FILL_RECT(th_canvas, 1, 1, 101, 101, red2)

    TNS: out_ta = image.THRESHHOLD_A(filled_th, 10111111)
    ASSERT(EQ(TLEN(out_ta, 1), TLEN(filled_th, 1)))
    ASSERT(EQ(image.CHANNELS(out_ta), image.CHANNELS(filled_th)))
    DEL(out_ta)

    TNS: out_tr = image.THRESHHOLD_R(filled_th, 10111111)
    ASSERT(EQ(TLEN(out_tr, 1), TLEN(filled_th, 1)))
    ASSERT(EQ(image.CHANNELS(out_tr), image.CHANNELS(filled_th)))
    DEL(out_tr)

    TNS: out_tg = image.THRESHHOLD_G(filled_th, 10111111)
    ASSERT(EQ(TLEN(out_tg, 1), TLEN(filled_th, 1)))
    ASSERT(EQ(image.CHANNELS(out_tg), image.CHANNELS(filled_th)))
    DEL(out_tg)

    TNS: out_tb = image.THRESHHOLD_B(filled_th, 10111111)
    ASSERT(EQ(TLEN(out_tb, 1), TLEN(filled_th, 1)))
    ASSERT(EQ(image.CHANNELS(out_tb), image.CHANNELS(filled_th)))
    DEL(out_tb)

    # Edge detector should preserve shape and channels
    TNS: edge_out = image.EDGE(filled_th)
    ASSERT(EQ(TLEN(edge_out, 1), TLEN(filled_th, 1)))
    ASSERT(EQ(image.CHANNELS(edge_out), image.CHANNELS(filled_th)))
    DEL(edge_out)

    # Cellshade maps pixels to palette; ensure output shape and channels preserved
    TNS: pal = [ ^
        [11111111, 0, 0, 11111111], ^
        [0, 11111111, 0, 11111111] ^
    ]
    TNS: cs_out = image.CELLSHADE(filled_th, pal)
    ASSERT(EQ(TLEN(cs_out, 1), TLEN(filled_th, 1)))
    ASSERT(EQ(image.CHANNELS(cs_out), image.CHANNELS(filled_th)))
    DEL(cs_out)

    DEL(filled_th)
    DEL(red2)
    DEL(th_canvas)

    PRINT("Image library tests passed.")
    # GUI tests: only run on Windows to avoid opening windows on CI/non-GUI hosts
    IF(EQ(OS(), "win")){
        INT: ghandle = gui.CREATE_WINDOW("scaled", 1100100, 111100, "Test GUI", 1)
        ASSERT( GT(ghandle, 0) )

        # Verify reported dimensions are positive (DPI/decoration may alter exact size)
        ASSERT( GT(gui.WINDOW_WIDTH(ghandle), 0) )
        ASSERT( GT(gui.WINDOW_HEIGHT(ghandle), 0) )

        # Window state operations
        ASSERT( EQ(gui.MINIMIZE(ghandle), 1) )
        ASSERT( EQ(gui.MAXIMIZE(ghandle), 1) )
        ASSERT( EQ(gui.TO_FRONT(ghandle), 1) )
        ASSERT( EQ(gui.TO_BACK(ghandle), 1) )

        ASSERT( EQ(gui.CLOSE_WINDOW(ghandle), 1) )
        DEL(ghandle)
        PRINT("GUI tests passed.")
    } ELSE {
        PRINT("Skipping GUI tests on non-Windows host.")
    }

    # diff library
    STR: _d_a = "line1\nline2\nline3"
    STR: _d_b = "line1\nlineX\nline3"
    ASSERT( EQ( BOOL(diff.UNIFIED(_d_a, _d_b)), 1 ) )
    ASSERT( EQ( BOOL(diff.CONTEXT(_d_a, _d_b)), 1 ) )
    ASSERT( EQ( BOOL(diff.SIDE_BY_SIDE(_d_a, _d_b)), 1 ) )
    DEL(_d_a)
    DEL(_d_b)
    PRINT("Diff extension tests passed.")

    PRINT("All standard library tests passed.\n")
    RETURN(0)
}

FUNC STDEXT_TESTS():INT{

    PRINT("Running extension tests...")

    # win32 extension
    ASSERT(EQ(win32.WIN_SLEEP(0), 0))
    INT: ticks = win32.WIN_CALL("kernel32", "GetTickCount64", "", "I")
    ASSERT(GTE(ticks, 0))
    INT: last_err = win32.WIN_LAST_ERROR()
    ASSERT(GTE(last_err, 0))
    PRINT("win32 extension tests passed.")

    # networking extension (local-only; no external internet required)
    INT: udp = networking.UDP_BIND("127.0.0.1", 0)
    ASSERT(GT(udp, 0))
    ASSERT(EQ(networking.UDP_CLOSE(udp), 0))
    PRINT("networking extension tests passed.")

    PRINT("All standard extension tests passed.\n")
    RETURN(0)
}

FUNC RUN_TESTS():INT{
    BUILTIN_TESTS()
    STDLIB_TESTS()
    STDEXT_TESTS()
    PRINT("All tests passed.")
    RETURN(0)
}

IF( EQ(MAIN(), 1) ){ RUN_TESTS() }